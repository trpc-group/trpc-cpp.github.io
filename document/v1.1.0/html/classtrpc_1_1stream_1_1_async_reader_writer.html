<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tRPC-Cpp: trpc::stream::AsyncReaderWriter&lt; R, W &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tRPC-Cpp<span id="projectnumber">&#160;1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetrpc.html">trpc</a></li><li class="navelem"><a class="el" href="namespacetrpc_1_1stream.html">stream</a></li><li class="navelem"><a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html">AsyncReaderWriter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">trpc::stream::AsyncReaderWriter&lt; R, W &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Asynchronous stream reader/writer.  
 <a href="classtrpc_1_1stream_1_1_async_reader_writer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stream__async_8h_source.html">stream_async.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for trpc::stream::AsyncReaderWriter&lt; R, W &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtrpc_1_1stream_1_1_async_reader_writer.png" usemap="#trpc::stream::AsyncReaderWriter_3C_20R_2C_20W_20_3E_map" alt=""/>
  <map id="trpc::stream::AsyncReaderWriter_3C_20R_2C_20W_20_3E_map" name="trpc::stream::AsyncReaderWriter_3C_20R_2C_20W_20_3E_map">
<area href="classtrpc_1_1_ref_counted.html" alt="trpc::RefCounted&lt; AsyncReaderWriter&lt; R, W &gt; &gt;" shape="rect" coords="0,0,293,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a681fba73bc0b0518a31e74dc3eb41a42" id="r_a681fba73bc0b0518a31e74dc3eb41a42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html#a681fba73bc0b0518a31e74dc3eb41a42">AsyncReaderWriter</a> (StreamReaderWriterProviderPtr provider, const MessageContentCodecOptions &amp;content_codec)</td></tr>
<tr class="memdesc:a681fba73bc0b0518a31e74dc3eb41a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">User usually don't need to construct one by themself.  <br /></td></tr>
<tr class="separator:a681fba73bc0b0518a31e74dc3eb41a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738fb1b58399a2ae40034cfe1a193ee0" id="r_a738fb1b58399a2ae40034cfe1a193ee0"><td class="memItemLeft" align="right" valign="top">Future&lt; std::optional&lt; R &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html#a738fb1b58399a2ae40034cfe1a193ee0">Read</a> (std::chrono::milliseconds timeout=std::chrono::milliseconds::max())</td></tr>
<tr class="memdesc:a738fb1b58399a2ae40034cfe1a193ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a packet from the stream.  <br /></td></tr>
<tr class="separator:a738fb1b58399a2ae40034cfe1a193ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dad68252215bd73db04c50c3f93b13" id="r_aa8dad68252215bd73db04c50c3f93b13"><td class="memItemLeft" align="right" valign="top">Future&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html#aa8dad68252215bd73db04c50c3f93b13">Write</a> (const W &amp;msg)</td></tr>
<tr class="memdesc:aa8dad68252215bd73db04c50c3f93b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a packet to the stream.  <br /></td></tr>
<tr class="separator:aa8dad68252215bd73db04c50c3f93b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e7c13ca5f9b5af6eb0d7314b5c12fd" id="r_ad9e7c13ca5f9b5af6eb0d7314b5c12fd"><td class="memItemLeft" align="right" valign="top">Future&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html#ad9e7c13ca5f9b5af6eb0d7314b5c12fd">Finish</a> ()</td></tr>
<tr class="memdesc:ad9e7c13ca5f9b5af6eb0d7314b5c12fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes the stream.  <br /></td></tr>
<tr class="separator:ad9e7c13ca5f9b5af6eb0d7314b5c12fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4953b843732896e078e8de8e47485ebd" id="r_a4953b843732896e078e8de8e47485ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetrpc_1_1stream.html#a442eba398491707e406f035a058bad0d">AsyncReaderPtr</a>&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html#a4953b843732896e078e8de8e47485ebd">Reader</a> () const</td></tr>
<tr class="memdesc:a4953b843732896e078e8de8e47485ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reader inside, which provides limited interfaces.  <br /></td></tr>
<tr class="separator:a4953b843732896e078e8de8e47485ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1de53fc0d43d505ef67916f9bc6cf1" id="r_add1de53fc0d43d505ef67916f9bc6cf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetrpc_1_1stream.html#a92d2ca323948a395a3ed2237b0f4e308">AsyncWriterPtr</a>&lt; W &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html#add1de53fc0d43d505ef67916f9bc6cf1">Writer</a> () const</td></tr>
<tr class="memdesc:add1de53fc0d43d505ef67916f9bc6cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the writer inside, which provides limited interfaces.  <br /></td></tr>
<tr class="separator:add1de53fc0d43d505ef67916f9bc6cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtrpc_1_1_ref_counted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtrpc_1_1_ref_counted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtrpc_1_1_ref_counted.html">trpc::RefCounted&lt; AsyncReaderWriter&lt; R, W &gt; &gt;</a></td></tr>
<tr class="memitem:a80c01def90817ae47c84116eed876a14 inherit pub_methods_classtrpc_1_1_ref_counted" id="r_a80c01def90817ae47c84116eed876a14"><td class="memItemLeft" align="right" valign="top">
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>Ref</b> () noexcept</td></tr>
<tr class="separator:a80c01def90817ae47c84116eed876a14 inherit pub_methods_classtrpc_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff6db6d54b9cad9073cf07cdf07d4dc inherit pub_methods_classtrpc_1_1_ref_counted" id="r_a3ff6db6d54b9cad9073cf07cdf07d4dc"><td class="memItemLeft" align="right" valign="top">
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>Deref</b> () noexcept</td></tr>
<tr class="separator:a3ff6db6d54b9cad9073cf07cdf07d4dc inherit pub_methods_classtrpc_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d739e8034fb35ffbab9dff6932dd28 inherit pub_methods_classtrpc_1_1_ref_counted" id="r_a81d739e8034fb35ffbab9dff6932dd28"><td class="memItemLeft" align="right" valign="top">
constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>UnsafeRefCount</b> () const noexcept</td></tr>
<tr class="separator:a81d739e8034fb35ffbab9dff6932dd28 inherit pub_methods_classtrpc_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename R, typename W&gt;<br />
class trpc::stream::AsyncReaderWriter&lt; R, W &gt;</div><p>Asynchronous stream reader/writer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Input packet type. </td></tr>
    <tr><td class="paramname">W</td><td>Output packet type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a681fba73bc0b0518a31e74dc3eb41a42" name="a681fba73bc0b0518a31e74dc3eb41a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681fba73bc0b0518a31e74dc3eb41a42">&#9670;&#160;</a></span>AsyncReaderWriter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html">trpc::stream::AsyncReaderWriter</a>&lt; R, W &gt;::AsyncReaderWriter </td>
          <td>(</td>
          <td class="paramtype">StreamReaderWriterProviderPtr&#160;</td>
          <td class="paramname"><em>provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MessageContentCodecOptions &amp;&#160;</td>
          <td class="paramname"><em>content_codec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User usually don't need to construct one by themself. </p>
<p>When user gets one, it also implies the stream is started already.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">provider</td><td>The stream on which operates. </td></tr>
    <tr><td class="paramname">content_codec</td><td>Information about packet (de)serialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad9e7c13ca5f9b5af6eb0d7314b5c12fd" name="ad9e7c13ca5f9b5af6eb0d7314b5c12fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e7c13ca5f9b5af6eb0d7314b5c12fd">&#9670;&#160;</a></span>Finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Future <a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html">trpc::stream::AsyncReaderWriter</a>&lt; R, W &gt;::Finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes the stream. </p>
<p>For client, a EOF will be sent to server automatically, something like WriteDone in other APIs. For server, nothing happens. It's recommended to call this for client, but optional for server because server will close the stream automatically after the returned future of user's service function becomes resolved. It makes no difference whether it's called from the reader, writer or readerwriter for specified stream. For one stream, it should be called at most once at each side, and it is also regarded as a writing operation, hence, it should be called after the previous writing(if any) is done, otherwise it's undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>A future which becomes ready while the stream is closed. For the current implementation, it never fails even stream error occurred. </dd></dl>

</div>
</div>
<a id="a738fb1b58399a2ae40034cfe1a193ee0" name="a738fb1b58399a2ae40034cfe1a193ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738fb1b58399a2ae40034cfe1a193ee0">&#9670;&#160;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; std::optional&lt; R &gt; &gt; <a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html">trpc::stream::AsyncReaderWriter</a>&lt; R, W &gt;::Read </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds::max()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a packet from the stream. </p>
<p>A reading should be started after the previous reading(if any) is done, i.e. at most one pending reading is allowed at a time, and should not be called anymore after the stream EOF read, otherwise it's undefined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Reading timeout, never timeout by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future which becomes ready while one packet got, with an empty optional value to indicate a stream EOF. If timeout occurred, future fails with an <code>Timeout</code> exception, however the stream operates normally. If any other error occurred, future fails with an <code>StreamError</code> exception with the stream status carried in most cases, then the stream stops as well, only <code>Finish</code> can be called. </dd></dl>

</div>
</div>
<a id="a4953b843732896e078e8de8e47485ebd" name="a4953b843732896e078e8de8e47485ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4953b843732896e078e8de8e47485ebd">&#9670;&#160;</a></span>Reader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetrpc_1_1stream.html#a442eba398491707e406f035a058bad0d">AsyncReaderPtr</a>&lt; R &gt; <a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html">trpc::stream::AsyncReaderWriter</a>&lt; R, W &gt;::Reader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reader inside, which provides limited interfaces. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to reader which operates on the same stream. </dd></dl>

</div>
</div>
<a id="aa8dad68252215bd73db04c50c3f93b13" name="aa8dad68252215bd73db04c50c3f93b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dad68252215bd73db04c50c3f93b13">&#9670;&#160;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Future <a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html">trpc::stream::AsyncReaderWriter</a>&lt; R, W &gt;::Write </td>
          <td>(</td>
          <td class="paramtype">const W &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a packet to the stream. </p>
<p>A writing should be started after the previous writing(if any) is done, i.e. at most one pending writing is allowed at a time, otherwise it's undefined behavior. A stream is a full-duplex communication channel, hence reading and writing can operate concurrently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future which becomes ready while the next writing is able to be started, which does NOT mean the packet is already sent on the wire. If any error occurred, future fails with an exception which is <code>StreamError</code> type with stream status carried at most cases, but other exception types are possible. </dd></dl>

</div>
</div>
<a id="add1de53fc0d43d505ef67916f9bc6cf1" name="add1de53fc0d43d505ef67916f9bc6cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1de53fc0d43d505ef67916f9bc6cf1">&#9670;&#160;</a></span>Writer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetrpc_1_1stream.html#a92d2ca323948a395a3ed2237b0f4e308">AsyncWriterPtr</a>&lt; W &gt; <a class="el" href="classtrpc_1_1stream_1_1_async_reader_writer.html">trpc::stream::AsyncReaderWriter</a>&lt; R, W &gt;::Writer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the writer inside, which provides limited interfaces. </p>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to writer which operates on the same stream. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>trpc/stream/<a class="el" href="stream__async_8h_source.html">stream_async.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 28 2023 11:25:48 for tRPC-Cpp by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
