<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tRPC-Cpp: trpc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tRPC-Cpp<span id="projectnumber">&#160;1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">trpc Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Primary namespace of tRPC-Cpp.  
<a href="namespacetrpc.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetrpc_1_1compressor" id="r_namespacetrpc_1_1compressor"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1compressor.html">compressor</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1compressor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression interfaces for user programing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1detail" id="r_namespacetrpc_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following are helper functions that should not be used directly by the user. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1fiber" id="r_namespacetrpc_1_1fiber"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1fiber.html">fiber</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1fiber"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace of fiber runtime. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1future" id="r_namespacetrpc_1_1future"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1future.html">future</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1future"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace contains interfaces used for future. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1http" id="r_namespacetrpc_1_1http"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1http.html">http</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1http"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace of http sub-module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1merge" id="r_namespacetrpc_1_1merge"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1merge.html">merge</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1merge"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace of merge runtime. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1metrics" id="r_namespacetrpc_1_1metrics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1metrics.html">metrics</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1metrics"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_metrics.html" title="The abstract interface definition for metrics plugins.">Metrics</a> interfaces for user programing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1prometheus" id="r_namespacetrpc_1_1prometheus"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1prometheus.html">prometheus</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1prometheus"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prometheus metrics interfaces for user programing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1rpcz" id="r_namespacetrpc_1_1rpcz"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1rpcz.html">rpcz</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1rpcz"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace to wrap rpcz interfaces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1runtime" id="r_namespacetrpc_1_1runtime"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1runtime.html">runtime</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1runtime"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace of trpc runtime. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1separate" id="r_namespacetrpc_1_1separate"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1separate.html">separate</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1separate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace of separate runtime. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1serialization" id="r_namespacetrpc_1_1serialization"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1serialization.html">serialization</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1serialization"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace of serialization implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1stream" id="r_namespacetrpc_1_1stream"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1stream.html">stream</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1stream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace of steam sub-module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1testing" id="r_namespacetrpc_1_1testing"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1testing.html">testing</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1testing"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provider some interfaces for testing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1time" id="r_namespacetrpc_1_1time"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1time.html">time</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1time"><td class="mdescLeft">&#160;</td><td class="mdescRight">The framework provides interfaces for obtaining various types of time. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrpc_1_1tvar" id="r_namespacetrpc_1_1tvar"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc_1_1tvar.html">tvar</a></td></tr>
<tr class="memdesc:namespacetrpc_1_1tvar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace to wrap tvar interfaces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_admin_handler_base.html">AdminHandlerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler holds the main logic for serving input commands by HTTP.  <a href="classtrpc_1_1_admin_handler_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1adopt__ptr__t.html">adopt_ptr_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_async_i_o.html">AsyncIO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous IO implementation based on io_uring This type of interface is not thread-safe, and currently only supports running in merge mode.  <a href="classtrpc_1_1_async_i_o.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_async_rpc_method_handler.html">AsyncRpcMethodHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of asynchronous rpc method handler.  <a href="classtrpc_1_1_async_rpc_method_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_async_rpc_service_impl.html">AsyncRpcServiceImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of async service.  <a href="classtrpc_1_1_async_rpc_service_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_async_stream_rpc_method_handler.html">AsyncStreamRpcMethodHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of asynchronous streaming RPC.  <a href="classtrpc_1_1_async_stream_rpc_method_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_async_timer.html">AsyncTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Async timer, use in merge/separate threadmodel.  <a href="classtrpc_1_1_async_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_bind_core_manager.html">BindCoreManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide core binding function to bind threads to specific logical CPUs.  <a href="classtrpc_1_1_bind_core_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_bounded_m_p_m_c_queue.html">BoundedMPMCQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of thread-safe lock-free queue, supports multi-producer and multi-consumer Refer: <a href="http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue">http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue</a> Paper: <a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf</a> see details.  <a href="classtrpc_1_1_bounded_m_p_m_c_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_bounded_m_p_s_c_queue.html">BoundedMPSCQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of thread-safe lock-free queue, supports multi-producer and single-consumer Refer: <a href="http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue">http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue</a> Paper: <a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf</a> see details.  <a href="classtrpc_1_1_bounded_m_p_s_c_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_bounded_s_p_m_c_queue.html">BoundedSPMCQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of thread-safe lock-free queue, supports single-producer and multi-consumer Paper: the paper "Correct and Efficient Work-Stealing for Weak Memory Models" see details: <a href="https://www.di.ens.fr/~zappa/readings/ppopp13.pdf">https://www.di.ens.fr/~zappa/readings/ppopp13.pdf</a>.  <a href="classtrpc_1_1_bounded_s_p_m_c_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_buffer_block.html">BufferBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Belongs to a middle layer object, mainly used by <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a>.  <a href="structtrpc_1_1_buffer_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_buffer_builder.html">BufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class used to create <code><a class="el" href="structtrpc_1_1_buffer_block.html" title="Belongs to a middle layer object, mainly used by NoncontiguousBuffer.">BufferBlock</a></code>.  <a href="classtrpc_1_1_buffer_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_buffer_pool_config.html">BufferPoolConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Related configuration of buffer memory pool within the framework.  <a href="structtrpc_1_1_buffer_pool_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_buffer_view.html">BufferView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>StringPiece</code>, used to view the memory pointed to by a pointer.  <a href="classtrpc_1_1_buffer_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_client_codec.html">ClientCodec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface (client-side) representing the ability to encode request message and decode response message.  <a href="classtrpc_1_1_client_codec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_client_codec_factory.html">ClientCodecFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The plugin factory class for client-side application layer protocol provides codec implementations for registering and obtaining various application layer protocols.  <a href="classtrpc_1_1_client_codec_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_client_config.html">ClientConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Client config.  <a href="structtrpc_1_1_client_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_client_context.html">ClientContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for client-side rpc invoke, every request has its own context, use <code>MakeClientContext</code> to create it.  <a href="classtrpc_1_1_client_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_client_ssl_config.html">ClientSslConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">content of ssl_cfg.yaml on client side like below: ... service:  <a href="structtrpc_1_1_client_ssl_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_client_tracing_span.html">ClientTracingSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tracing-related data that client saves in the context for transmission.  <a href="structtrpc_1_1_client_tracing_span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_common_exception.html">CommonException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common exception.  <a href="classtrpc_1_1_common_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_contiguous_buffer.html">ContiguousBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of contiguous buffer.  <a href="classtrpc_1_1_contiguous_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_create_static.html">CreateStatic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <code>static</code> to create singleton object.  <a href="classtrpc_1_1_create_static.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_create_using_new.html">CreateUsingNew</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <code>new</code> to create singleton object.  <a href="classtrpc_1_1_create_using_new.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_default_lifetime.html">DefaultLifetime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the singleton object when the program exits.  <a href="classtrpc_1_1_default_lifetime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_default_log.html">DefaultLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "default" log plugin provided by trpc-cpp, based on spdlog, supports multi-sink extension.  <a href="classtrpc_1_1_default_log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_default_thread_model_instance_config.html">DefaultThreadModelInstanceConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Io/handle merge/separate threadmodel instance config.  <a href="structtrpc_1_1_default_thread_model_instance_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_deferred.html">Deferred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call action on destruction. Moveable. Dismissable.  <a href="classtrpc_1_1_deferred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_delayed_init.html">DelayedInit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows you to delay initialization of an object.  <a href="classtrpc_1_1_delayed_init.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_erased_ptr.html">ErasedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper for holding type erased pointers.  <a href="classtrpc_1_1_erased_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_exception.html">Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_exception_base.html">ExceptionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classtrpc_1_1_exception.html">Exception</a>.  <a href="classtrpc_1_1_exception_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_executor.html">Executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for how to execute future task.  <a href="classtrpc_1_1_executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber.html">Fiber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <code>std::thread</code>, but it's for fiber.  <a href="classtrpc_1_1_fiber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_blocking_bounded_queue.html">FiberBlockingBoundedQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BoundedQueue for fiber, you can Push,Pop.  <a href="classtrpc_1_1_fiber_blocking_bounded_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_blocking_noncontiguous_buffer.html">FiberBlockingNoncontiguousBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> for fiber, you can Append,Cut.  <a href="classtrpc_1_1_fiber_blocking_noncontiguous_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_condition_variable.html">FiberConditionVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive condition variable primitive for both fiber and pthread context.  <a href="classtrpc_1_1_fiber_condition_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_event.html">FiberEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive event primitive for both fiber and pthread context.  <a href="classtrpc_1_1_fiber_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_execution_context.html">FiberExecutionContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classtrpc_1_1_fiber_execution_context.html" title="FiberExecutionContext serves as a container for all information relevant to a logical fiber / a group...">FiberExecutionContext</a></code> serves as a container for all information relevant to a logical fiber / a group of fibers of execution.  <a href="classtrpc_1_1_fiber_execution_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_execution_local.html">FiberExecutionLocal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local storage a given fiber execution context.  <a href="classtrpc_1_1_fiber_execution_local.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_latch.html">FiberLatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive latch primitive for both fiber and pthread context.  <a href="classtrpc_1_1_fiber_latch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_local.html">FiberLocal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>T</code> needs to be <code>DefaultConstructible</code>.  <a href="classtrpc_1_1_fiber_local.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_seq_lock.html">FiberSeqLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reader/writer consistent mechanism without starving writers.  <a href="classtrpc_1_1_fiber_seq_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_shared_mutex.html">FiberSharedMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive shared mutex primitive for both fiber and pthread context.  <a href="classtrpc_1_1_fiber_shared_mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_fiber_thread_model_instance_config.html">FiberThreadModelInstanceConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber(m:n coroutine) threadmodel instance config.  <a href="structtrpc_1_1_fiber_thread_model_instance_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_timed_mutex.html">FiberTimedMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <code>std::timed_mutex</code> alternative for fiber.  <a href="classtrpc_1_1_fiber_timed_mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_fiber_timer_killer.html">FiberTimerKiller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managing timer using RAII.  <a href="classtrpc_1_1_fiber_timer_killer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_filter.html">Filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_filter.html" title="Filter template base class.">Filter</a> template base class.  <a href="classtrpc_1_1_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_filter_3_01_client_context_ptr_01_4.html">Filter&lt; ClientContextPtr &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Client filter.  <a href="classtrpc_1_1_filter_3_01_client_context_ptr_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_filter_3_01_server_context_ptr_01_4.html">Filter&lt; ServerContextPtr &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for server-side filters.  <a href="classtrpc_1_1_filter_3_01_server_context_ptr_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_forward_rpc_method_handler.html">ForwardRpcMethodHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of rpc transparent transmission method handler.  <a href="classtrpc_1_1_forward_rpc_method_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_forward_rpc_service_impl.html">ForwardRpcServiceImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of Rpc transparent transmission service.  <a href="classtrpc_1_1_forward_rpc_service_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note that although some of the implementation of <code>std::function&lt;...&gt;</code> (including libstdc++, but not libc++, as of 20181126) is.  <a href="classtrpc_1_1_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_function_3_01_r_07_args_8_8_8_08_4.html">Function&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This extension is only implemented by GCC / clang.  <a href="classtrpc_1_1_function_3_01_r_07_args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_function_view.html">FunctionView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_function_view_3_01_r_07_args_8_8_8_08_01noexcept_07k_noexcept_08_4.html">FunctionView&lt; R(Args...) noexcept(kNoexcept)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction of <code>noexcept</code> is not part of C++17, actually.  <a href="classtrpc_1_1_function_view_3_01_r_07_args_8_8_8_08_01noexcept_07k_noexcept_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_futex_notifier.html">FutexNotifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waking up/notifying between multiple threads based on futex reference implementation: <a href="https://github.com/apache/incubator-brpc/blob/master/src/bthread/parking_lot.h">https://github.com/apache/incubator-brpc/blob/master/src/bthread/parking_lot.h</a>.  <a href="classtrpc_1_1_futex_notifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_future_3_01_t_01_4.html">Future&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Future's specialized version with single parameter.  <a href="classtrpc_1_1_future_3_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_futurize.html">Futurize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_futurize_base.html">FuturizeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_futurize_base_3_01_future_3_01_t_01_4_01_4.html">FuturizeBase&lt; Future&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_futurize_base_3_01_future_3_4_01_4.html">FuturizeBase&lt; Future&lt;&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_futurize_base_3_01void_01_4.html">FuturizeBase&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_global_config.html">GlobalConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Framework global configuration information.  <a href="structtrpc_1_1_global_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_hazptr.html">Hazptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_hazptr_domain.html">HazptrDomain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_hazptr_object.html">HazptrObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_heartbeat_config.html">HeartbeatConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Related configuration of heart-beat within the framework.  <a href="structtrpc_1_1_heartbeat_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_heart_beat_report.html">HeartBeatReport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This singleton class is used for service and thread heartbeat reporting, it includes the following features:  <a href="classtrpc_1_1_heart_beat_report.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_http_service.html">HttpService</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches HTTP request to specific HTTP handler based on request routes which is initialized by user.  <a href="classtrpc_1_1_http_service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_inline_executor.html">InlineExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executed future task inside current thread.  <a href="classtrpc_1_1_inline_executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_invoke_result.html">InvokeResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing the service discovery invocation result for external use.  <a href="structtrpc_1_1_invoke_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_is_future.html">IsFuture</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_is_future_3_01_future_3_01_t_8_8_8_01_4_01_4.html">IsFuture&lt; Future&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_latch.html">Latch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A downward counter of type std::ptrdiff_t which can be used to synchronize threads.  <a href="classtrpc_1_1_latch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_limiter.html">Limiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for limiter plugins.  <a href="classtrpc_1_1_limiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_limiter_factory.html">LimiterFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_limiter.html" title="Base class for limiter plugins.">Limiter</a> plugin factory.  <a href="classtrpc_1_1_limiter_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_limit_info.html">LimitInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of service rate limiting information.  <a href="structtrpc_1_1_limit_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_limit_result.html">LimitResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of rate limiting result, used for rate limiting reporting.  <a href="structtrpc_1_1_limit_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_load_balance.html">LoadBalance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load balancing base class.  <a href="classtrpc_1_1_load_balance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_load_balance_factory.html">LoadBalanceFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load balance plugin factory.  <a href="classtrpc_1_1_load_balance_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_load_balance_info.html">LoadBalanceInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_load_balance_result.html">LoadBalanceResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_lock_exception.html">LockException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_lock_free_queue.html">LockFreeQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a thread-safe lock-free queue that supports multiple producers and multiple consumers (multiple threads simultaneously fetching/putting data).  <a href="classtrpc_1_1_lock_free_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_log.html">Log</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_logging.html">Logging</a> plugin base class, support multiple instances, log levels and log attributes.  <a href="classtrpc_1_1_log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_log_factory.html">LogFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_logging.html">Logging</a> plugin factories: Only the "default" log plugins provided by the framework are allowed to register, also designed as factories to unify the design style of all plugins in the framework.  <a href="classtrpc_1_1_log_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_logging.html">Logging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_make_ready_future_helper.html">MakeReadyFutureHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to Future constructor.  <a href="structtrpc_1_1_make_ready_future_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_metrics.html">Metrics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract interface definition for metrics plugins.  <a href="classtrpc_1_1_metrics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_module_metrics_info.html">ModuleMetricsInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_metrics.html" title="The abstract interface definition for metrics plugins.">Metrics</a> data for inter-module calls.  <a href="structtrpc_1_1_module_metrics_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_m_q_thread_pool.html">MQThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of task-steal thread pool The difference between this class and <code><a class="el" href="classtrpc_1_1_s_q_thread_pool.html" title="The implementation of shared task queue thread pool usage:">SQThreadPool</a></code> is: this class there are two queues:  <a href="classtrpc_1_1_m_q_thread_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_m_q_thread_pool_task.html">MQThreadPoolTask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_m_q_thread_pool_worker.html">MQThreadPoolWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The worker of <a class="el" href="classtrpc_1_1_m_q_thread_pool.html" title="The implementation of task-steal thread pool The difference between this class and SQThreadPool is: t...">MQThreadPool</a>.  <a href="classtrpc_1_1_m_q_thread_pool_worker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_multi_attr_metrics_info.html">MultiAttrMetricsInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_metrics.html" title="The abstract interface definition for metrics plugins.">Metrics</a> data with multi-dimensional attributes.  <a href="structtrpc_1_1_multi_attr_metrics_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_no_destroy_lifetime.html">NoDestroyLifetime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Never Destroy.  <a href="structtrpc_1_1_no_destroy_lifetime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_noncontiguous_boyer_moore_searcher.html">NoncontiguousBoyerMooreSearcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of contiguous buffer <code><a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a></code> is composed of multiple contiguous memory block <code><a class="el" href="structtrpc_1_1_buffer_block.html" title="Belongs to a middle layer object, mainly used by NoncontiguousBuffer.">BufferBlock</a></code> objects, Each <a class="el" href="structtrpc_1_1_buffer_block.html" title="Belongs to a middle layer object, mainly used by NoncontiguousBuffer.">BufferBlock</a> contains a fixed-size contiguous memory block <code>MemBlock</code>.  <a href="classtrpc_1_1_noncontiguous_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_noncontiguous_buffer_builder.html">NoncontiguousBufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The helper class used to construct a <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> object.  <a href="classtrpc_1_1_noncontiguous_buffer_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_noncontiguous_buffer_input_stream.html">NoncontiguousBufferInputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides you a way to parse <a class="el" href="classtrpc_1_1_protocol.html" title="An interface representing the ability to decode and encode a protocol message.">Protocol</a> Buffers from <code><a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a></code> without flattening the later.  <a href="classtrpc_1_1_noncontiguous_buffer_input_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_noncontiguous_buffer_output_stream.html">NoncontiguousBufferOutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides you a way to serialize <a class="el" href="classtrpc_1_1_protocol.html" title="An interface representing the ability to decode and encode a protocol message.">Protocol</a> Buffers into <code><a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a></code>.  <a href="classtrpc_1_1_noncontiguous_buffer_output_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_non_rpc_method_handler.html">NonRpcMethodHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of non-rpc method handler.  <a href="classtrpc_1_1_non_rpc_method_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_non_rpc_method_handler_interface.html">NonRpcMethodHandlerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for non-rpc processing methods  <a href="classtrpc_1_1_non_rpc_method_handler_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_non_rpc_service_impl.html">NonRpcServiceImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of non-rpc service.  <a href="classtrpc_1_1_non_rpc_service_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_non_rpc_service_method.html">NonRpcServiceMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-rpc service method  <a href="classtrpc_1_1_non_rpc_service_method.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_non_rpc_service_proxy.html">NonRpcServiceProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-rpc service proxy.  <a href="classtrpc_1_1_non_rpc_service_proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_pb2_json.html">Pb2Json</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of conversion between pb and json.  <a href="classtrpc_1_1_pb2_json.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_periphery_task_scheduler.html">PeripheryTaskScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to execute periodic/non-periodic tasks.  <a href="classtrpc_1_1_periphery_task_scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_per_thread_worker.html">PerThreadWorker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_plugin.html">Plugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tRPC all plugin abstract base class  <a href="classtrpc_1_1_plugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_predicate_notifier.html">PredicateNotifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_predicate_notifier.html" title="PredicateNotifier allows to wait for arbitrary predicates in non-blocking algorithms.">PredicateNotifier</a> allows to wait for arbitrary predicates in non-blocking algorithms.  <a href="classtrpc_1_1_predicate_notifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_promise_3_01_t_01_4.html">Promise&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single parameter version of Promise.  <a href="classtrpc_1_1_promise_3_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_protocol.html">Protocol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface representing the ability to decode and encode a protocol message.  <a href="classtrpc_1_1_protocol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_proxy_callback.html">ProxyCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function, it can be specified by user.  <a href="structtrpc_1_1_proxy_callback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_redis_client_conf.html">RedisClientConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Client config for accessing redis Mainly contains authentication information.  <a href="structtrpc_1_1_redis_client_conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1ref__ptr__t.html">ref_ptr_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_ref_counted.html">RefCounted</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_ref_traits.html">RefTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_ref_traits_3_01_ref_counted_3_01_t_00_01_deleter_01_4_01_4.html">RefTraits&lt; RefCounted&lt; T, Deleter &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_ref_traits_3_01_t_00_01std_1_1enable__if__t_3_9std_1_1is__same__v_3_01detail_1_1aeac71ec4d3cec6023b50a7a840fa67fc.html">RefTraits&lt; T, std::enable_if_t&lt;!std::is_same_v&lt; detail::as_ref_counted_t&lt; T &gt;, T &gt; &amp;&amp;detail::is_default_ref_traits_safe_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for service registry plugins.  <a href="classtrpc_1_1_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_registry_factory.html">RegistryFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_service.html" title="Base class for service.">Service</a> registry plugin factory.  <a href="classtrpc_1_1_registry_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_registry_info.html">RegistryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of service registration information.  <a href="structtrpc_1_1_registry_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_retry_hedging_limit_config.html">RetryHedgingLimitConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thresholds related to the retry hedging and rate limiting strategy.  <a href="structtrpc_1_1_retry_hedging_limit_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_retry_limit_client_filter.html">RetryLimitClientFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rate limiting protection filter that used in conjunction with the backup request retry feature.  <a href="classtrpc_1_1_retry_limit_client_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_router_info.html">RouterInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_service.html" title="Base class for service.">Service</a> routing information.  <a href="structtrpc_1_1_router_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_rpc_client_filter.html">RpcClientFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate filters before and after client-side RPC calls to facilitate user inheritance and use.  <a href="classtrpc_1_1_rpc_client_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_rpc_method_handler.html">RpcMethodHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of rpc method handler.  <a href="classtrpc_1_1_rpc_method_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_rpc_method_handler_interface.html">RpcMethodHandlerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for rpc processing methods  <a href="classtrpc_1_1_rpc_method_handler_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_rpc_server_filter.html">RpcServerFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate filters before and after server-side RPC calls to facilitate user inheritance and use.  <a href="classtrpc_1_1_rpc_server_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_rpc_service_impl.html">RpcServiceImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of rpc service.  <a href="classtrpc_1_1_rpc_service_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_rpc_service_method.html">RpcServiceMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rpc service method.  <a href="classtrpc_1_1_rpc_service_method.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_rpc_service_proxy.html">RpcServiceProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rpc service proxy.  <a href="classtrpc_1_1_rpc_service_proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_rpcz_config.html">RpczConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurations for rpcz.  <a href="structtrpc_1_1_rpcz_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_r_w_lock.html">RWLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write lock based on asynchronouse semaphore, which write lock takes all available units.  <a href="classtrpc_1_1_r_w_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_r_w_lock_for_read.html">RWLockForRead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_r_w_lock_for_write.html">RWLockForWrite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_scoped_deferred.html">ScopedDeferred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>F</code> on destruction.  <a href="classtrpc_1_1_scoped_deferred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_selector.html">Selector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for service discovery.  <a href="classtrpc_1_1_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_selector_factory.html">SelectorFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_service.html" title="Base class for service.">Service</a> discovery plugin factory.  <a href="classtrpc_1_1_selector_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_selector_info.html">SelectorInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of service discovery request.  <a href="structtrpc_1_1_selector_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_semaphore.html">Semaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Async semaphore based on future, you can deposit or withdraw units, and withdrawl may wait if there is not enough units.  <a href="classtrpc_1_1_semaphore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_semaphore_exception.html">SemaphoreException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_separate_thread_model_scheduling_config.html">SeparateThreadModelSchedulingConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate threadmodel logic task scheduling config.  <a href="structtrpc_1_1_separate_thread_model_scheduling_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_server_codec.html">ServerCodec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface (server-side) representing the ability to decode request message and encode response message.  <a href="classtrpc_1_1_server_codec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_server_codec_factory.html">ServerCodecFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The plugin factory class for server-side application layer protocol provides codec implementations for registering and obtaining various application layer protocols.  <a href="classtrpc_1_1_server_codec_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_server_config.html">ServerConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Server config.  <a href="structtrpc_1_1_server_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_server_context.html">ServerContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context class for server-side request processing, use <code>MakeServerContext</code> to create it.  <a href="classtrpc_1_1_server_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_server_ssl_config.html">ServerSslConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">content of ssl_cfg.yaml on server side like below: ... service:  <a href="structtrpc_1_1_server_ssl_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_server_tracing_span.html">ServerTracingSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tracing-related data that server saves in the context for transmission.  <a href="structtrpc_1_1_server_tracing_span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_service.html">Service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for service.  <a href="classtrpc_1_1_service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_service_config.html">ServiceConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_service.html" title="Base class for service.">Service</a> Configuration.  <a href="structtrpc_1_1_service_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_service_heart_beat_info.html">ServiceHeartBeatInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">service-level heartbeat information, used to do heartbeat reporting to the naming service.  <a href="structtrpc_1_1_service_heart_beat_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_service_proxy.html">ServiceProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of service proxy.  <a href="classtrpc_1_1_service_proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_service_proxy_config.html">ServiceProxyConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_service_proxy.html" title="Base class of service proxy.">ServiceProxy</a> config <code><a class="el" href="classtrpc_1_1_service.html" title="Base class for service.">Service</a> level config</code>, If you want to use <code>Request-level config</code>, use <code><a class="el" href="classtrpc_1_1_client_context.html" title="Context for client-side rpc invoke, every request has its own context, use MakeClientContext to creat...">ClientContext</a></code>  <a href="structtrpc_1_1_service_proxy_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_service_proxy_option.html">ServiceProxyOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options of service proxy.  <a href="structtrpc_1_1_service_proxy_option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_simple_non_rpc_service_impl.html">SimpleNonRpcServiceImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulated non-rpc request processing, convenient for users.  <a href="classtrpc_1_1_simple_non_rpc_service_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_single_attr_metrics_info.html">SingleAttrMetricsInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_metrics.html" title="The abstract interface definition for metrics plugins.">Metrics</a> data with single-dimensional attribute.  <a href="structtrpc_1_1_single_attr_metrics_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_singleton.html">Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation for singleton.  <a href="classtrpc_1_1_singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_spinlock.html">Spinlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SpinLock implementation class.  <a href="classtrpc_1_1_spinlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_s_q_thread_pool.html">SQThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of shared task queue thread pool usage:  <a href="classtrpc_1_1_s_q_thread_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_ssl_config.html">SslConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains certificate, ciphers, protocols of TLS.  <a href="structtrpc_1_1_ssl_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_status.html">Status</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status information class returned by the RPC call.  <a href="classtrpc_1_1_status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_stream_rpc_method_handler.html">StreamRpcMethodHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of streaming RPC.  <a href="classtrpc_1_1_stream_rpc_method_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_telemetry.html">Telemetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract interface definition for telemetry plugins.  <a href="classtrpc_1_1_telemetry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_thread_cond.html">ThreadCond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread condition variable class, where all locks can wait for a signal to occur on it.  <a href="classtrpc_1_1_thread_cond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_thread_local.html">ThreadLocal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_thread_lock_t.html">ThreadLockT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock template class is used in conjunction with other specific locks.  <a href="classtrpc_1_1_thread_lock_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_thread_model.html">ThreadModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for implement a threading model.  <a href="classtrpc_1_1_thread_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_thread_model_config.html">ThreadModelConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Framework threadmodel configuration.  <a href="structtrpc_1_1_thread_model_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_thread_model_manager.html">ThreadModelManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Management class for thread model.  <a href="classtrpc_1_1_thread_model_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_thread_monitor.html">ThreadMonitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Usually, thread locks are used through this class, i.e.  <a href="classtrpc_1_1_thread_monitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_thread_mutex.html">ThreadMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-reentrant locking, meaning the same thread cannot lock again.  <a href="classtrpc_1_1_thread_mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_thread_pool_impl.html">ThreadPoolImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of thread pool usage:  <a href="classtrpc_1_1_thread_pool_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_thread_pool_option.html">ThreadPoolOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread pool initialization parameters.  <a href="structtrpc_1_1_thread_pool_option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_thread_rec_mutex.html">ThreadRecMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread recursive lock class.  <a href="classtrpc_1_1_thread_rec_mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_thread_try_lock_t.html">ThreadTryLockT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for attempting to acquire a lock.  <a href="classtrpc_1_1_thread_try_lock_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_time_provider.html">TimeProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_time_string_helper.html">TimeStringHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_tracing.html">Tracing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract interface definition for tracing plugins.  <a href="classtrpc_1_1_tracing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_trpc_app.html">TrpcApp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for trpc application program.  <a href="classtrpc_1_1_trpc_app.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_circuit_break_white_list.html">TrpcCircuitBreakWhiteList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circuit breaker whitelist related to framework error codes.  <a href="structtrpc_1_1_trpc_circuit_break_white_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_trpc_client.html">TrpcClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of trpc client.  <a href="classtrpc_1_1_trpc_client.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_trpc_config.html">TrpcConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For trpc framework config.  <a href="classtrpc_1_1_trpc_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_endpoint_info.html">TrpcEndpointInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of service discovery result for external use.  <a href="structtrpc_1_1_trpc_endpoint_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_invoke_result.html">TrpcInvokeResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of service discovery invocation result.  <a href="structtrpc_1_1_trpc_invoke_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_limit_info.html">TrpcLimitInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of service rate limiting information in external interface.  <a href="structtrpc_1_1_trpc_limit_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_limit_result.html">TrpcLimitResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of rate limiting invocation result.  <a href="structtrpc_1_1_trpc_limit_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_module_metrics_info.html">TrpcModuleMetricsInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trpc metrics data for inter-module calls.  <a href="structtrpc_1_1_trpc_module_metrics_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_multi_attr_metrics_info.html">TrpcMultiAttrMetricsInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trpc metrics data with multi-dimensional attributes.  <a href="structtrpc_1_1_trpc_multi_attr_metrics_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_trpc_plugin.html">TrpcPlugin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_plugin.html" title="tRPC all plugin abstract base class">Plugin</a> management class.  <a href="classtrpc_1_1_trpc_plugin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_registry_info.html">TrpcRegistryInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of service registration information for external use.  <a href="structtrpc_1_1_trpc_registry_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_router_info.html">TrpcRouterInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing the service routing information for external use.  <a href="structtrpc_1_1_trpc_router_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_selector_info.html">TrpcSelectorInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of service discovery information for external use.  <a href="structtrpc_1_1_trpc_selector_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_trpc_single_attr_metrics_info.html">TrpcSingleAttrMetricsInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trpc metrics data with single-dimensional attribute.  <a href="structtrpc_1_1_trpc_single_attr_metrics_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_try_parse_traits.html">TryParseTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation goes below.  <a href="structtrpc_1_1_try_parse_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_try_parse_traits_3_01bool_01_4.html">TryParseTraits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_try_parse_traits_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__floating__point__v_3_01_t_01_4_01_4_01_4.html">TryParseTraits&lt; T, std::enable_if_t&lt; std::is_floating_point_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_try_parse_traits_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__integral__v_3_01_t_01_4_01_4_01_4.html">TryParseTraits&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrpc_1_1_tvar_config.html">TvarConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurations for tvar.  <a href="structtrpc_1_1_tvar_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_unary_rpc_error.html">UnaryRpcError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary rpc error exception, for async future invoke.  <a href="classtrpc_1_1_unary_rpc_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_unary_rpc_method_handler.html">UnaryRpcMethodHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common implementation class for unary rpc method handler.  <a href="classtrpc_1_1_unary_rpc_method_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_unbounded_s_p_m_c_queue.html">UnboundedSPMCQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free unbounded single-producer multiple-consumer queue.  <a href="classtrpc_1_1_unbounded_s_p_m_c_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_unique_id.html">UniqueId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate unique id class  <a href="classtrpc_1_1_unique_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeab3931bd21b1d55846161c3e5dd80bf" id="r_aeab3931bd21b1d55846161c3e5dd80bf"><td class="memItemLeft" align="right" valign="top"><a id="aeab3931bd21b1d55846161c3e5dd80bf" name="aeab3931bd21b1d55846161c3e5dd80bf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ClientContextPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_client_context.html">ClientContext</a> &gt;</td></tr>
<tr class="separator:aeab3931bd21b1d55846161c3e5dd80bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e6000a39270fda3256024a07d4f920" id="r_a57e6000a39270fda3256024a07d4f920"><td class="memTemplParams" colspan="2"><a id="a57e6000a39270fda3256024a07d4f920" name="a57e6000a39270fda3256024a07d4f920"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57e6000a39270fda3256024a07d4f920"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_client_context</b> = std::is_same&lt; T, <a class="el" href="classtrpc_1_1_client_context.html">ClientContext</a> &gt;</td></tr>
<tr class="separator:a57e6000a39270fda3256024a07d4f920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110a4d0f8a2121d80262036f4eb57333" id="r_a110a4d0f8a2121d80262036f4eb57333"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a110a4d0f8a2121d80262036f4eb57333">MakeClientContextCallback</a> = std::function&lt; void(const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;, <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a110a4d0f8a2121d80262036f4eb57333"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used by plugin developers to register how to set the contents of the server context into the client context when create clientcontext using MakeClientContext (no thread-safe).  <br /></td></tr>
<tr class="separator:a110a4d0f8a2121d80262036f4eb57333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80b8fe198b26a3bd2b523d3d96357c9" id="r_ac80b8fe198b26a3bd2b523d3d96357c9"><td class="memItemLeft" align="right" valign="top"><a id="ac80b8fe198b26a3bd2b523d3d96357c9" name="ac80b8fe198b26a3bd2b523d3d96357c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ServiceProxyPtr</b> = std::shared_ptr&lt; <a class="el" href="classtrpc_1_1_service_proxy.html">ServiceProxy</a> &gt;</td></tr>
<tr class="separator:ac80b8fe198b26a3bd2b523d3d96357c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd8accf1e7a9cc32655dac50da35dc" id="r_a9cbd8accf1e7a9cc32655dac50da35dc"><td class="memItemLeft" align="right" valign="top"><a id="a9cbd8accf1e7a9cc32655dac50da35dc" name="a9cbd8accf1e7a9cc32655dac50da35dc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ClientTimeoutHandleFunction</b> = std::function&lt; void(const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a9cbd8accf1e7a9cc32655dac50da35dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_function.html" title="Note that although some of the implementation of std::function&lt;...&gt; (including libstdc++,...">Function</a> to handle invoke timeout event. <br /></td></tr>
<tr class="separator:a9cbd8accf1e7a9cc32655dac50da35dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd3481f35fd3e61d866770cbc0f2dba" id="r_abfd3481f35fd3e61d866770cbc0f2dba"><td class="memItemLeft" align="right" valign="top"><a id="abfd3481f35fd3e61d866770cbc0f2dba" name="abfd3481f35fd3e61d866770cbc0f2dba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CreateTransportFunction</b> = std::function&lt; std::unique_ptr&lt; ClientTransport &gt;()&gt;</td></tr>
<tr class="memdesc:abfd3481f35fd3e61d866770cbc0f2dba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtrpc_1_1_function.html" title="Note that although some of the implementation of std::function&lt;...&gt; (including libstdc++,...">Function</a> to create a client transport, used for scenarios that require custom transport, such as network mocking. <br /></td></tr>
<tr class="separator:abfd3481f35fd3e61d866770cbc0f2dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e0a3feef0a60d5e42de46785515d01" id="r_a04e0a3feef0a60d5e42de46785515d01"><td class="memItemLeft" align="right" valign="top"><a id="a04e0a3feef0a60d5e42de46785515d01" name="a04e0a3feef0a60d5e42de46785515d01"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TrpcServiceProxy</b> = <a class="el" href="classtrpc_1_1_rpc_service_proxy.html">RpcServiceProxy</a></td></tr>
<tr class="separator:a04e0a3feef0a60d5e42de46785515d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7605f41dddab119fe98cbe657e0742ff" id="r_a7605f41dddab119fe98cbe657e0742ff"><td class="memItemLeft" align="right" valign="top"><a id="a7605f41dddab119fe98cbe657e0742ff" name="a7605f41dddab119fe98cbe657e0742ff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ClientCodecPtr</b> = std::shared_ptr&lt; <a class="el" href="classtrpc_1_1_client_codec.html">ClientCodec</a> &gt;</td></tr>
<tr class="separator:a7605f41dddab119fe98cbe657e0742ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c11b5c261164482aab940005cc0d9c9" id="r_a5c11b5c261164482aab940005cc0d9c9"><td class="memItemLeft" align="right" valign="top"><a id="a5c11b5c261164482aab940005cc0d9c9" name="a5c11b5c261164482aab940005cc0d9c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ServerContextPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_server_context.html">ServerContext</a> &gt;</td></tr>
<tr class="separator:a5c11b5c261164482aab940005cc0d9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e20db355c4c0dc003f88d0fe7717b2" id="r_ae6e20db355c4c0dc003f88d0fe7717b2"><td class="memItemLeft" align="right" valign="top"><a id="ae6e20db355c4c0dc003f88d0fe7717b2" name="ae6e20db355c4c0dc003f88d0fe7717b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ServerCodecPtr</b> = std::shared_ptr&lt; <a class="el" href="classtrpc_1_1_server_codec.html">ServerCodec</a> &gt;</td></tr>
<tr class="separator:ae6e20db355c4c0dc003f88d0fe7717b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397bc19b3d9f7ee47981a9021dc6e867" id="r_a397bc19b3d9f7ee47981a9021dc6e867"><td class="memItemLeft" align="right" valign="top"><a id="a397bc19b3d9f7ee47981a9021dc6e867" name="a397bc19b3d9f7ee47981a9021dc6e867"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RpcCallType</b> = uint8_t</td></tr>
<tr class="separator:a397bc19b3d9f7ee47981a9021dc6e867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6001925f1a00ab41ddb779f784002b4" id="r_ab6001925f1a00ab41ddb779f784002b4"><td class="memItemLeft" align="right" valign="top"><a id="ab6001925f1a00ab41ddb779f784002b4" name="ab6001925f1a00ab41ddb779f784002b4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TransInfoMap</b> = google::protobuf::Map&lt; std::string, std::string &gt;</td></tr>
<tr class="memdesc:ab6001925f1a00ab41ddb779f784002b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the mapping name of pass-through information. <br /></td></tr>
<tr class="separator:ab6001925f1a00ab41ddb779f784002b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0b4b5290b572eaa8ebb77816f5608c" id="r_a1e0b4b5290b572eaa8ebb77816f5608c"><td class="memItemLeft" align="right" valign="top"><a id="a1e0b4b5290b572eaa8ebb77816f5608c" name="a1e0b4b5290b572eaa8ebb77816f5608c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ProtocolPtr</b> = std::shared_ptr&lt; <a class="el" href="classtrpc_1_1_protocol.html">Protocol</a> &gt;</td></tr>
<tr class="separator:a1e0b4b5290b572eaa8ebb77816f5608c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511e4d419c8eaefb6c567889ecc9d7ad" id="r_a511e4d419c8eaefb6c567889ecc9d7ad"><td class="memItemLeft" align="right" valign="top"><a id="a511e4d419c8eaefb6c567889ecc9d7ad" name="a511e4d419c8eaefb6c567889ecc9d7ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PluginPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_plugin.html">Plugin</a> &gt;</td></tr>
<tr class="separator:a511e4d419c8eaefb6c567889ecc9d7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c680addb091803b967623b5b4bea12d" id="r_a3c680addb091803b967623b5b4bea12d"><td class="memItemLeft" align="right" valign="top"><a id="a3c680addb091803b967623b5b4bea12d" name="a3c680addb091803b967623b5b4bea12d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FiberMutex</b> = ::trpc::fiber::detail::Mutex</td></tr>
<tr class="memdesc:a3c680addb091803b967623b5b4bea12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive mutex primitive for both fiber and pthread context. <br /></td></tr>
<tr class="separator:a3c680addb091803b967623b5b4bea12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc2b4bede20fd1001fc823d0f558cae" id="r_a9fc2b4bede20fd1001fc823d0f558cae"><td class="memItemLeft" align="right" valign="top"><a id="a9fc2b4bede20fd1001fc823d0f558cae" name="a9fc2b4bede20fd1001fc823d0f558cae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MessageClientFilter</b> = <a class="el" href="classtrpc_1_1_filter.html">Filter</a>&lt; <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &gt;</td></tr>
<tr class="separator:a9fc2b4bede20fd1001fc823d0f558cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ee2c697723438ceea05de698d99fc0" id="r_a04ee2c697723438ceea05de698d99fc0"><td class="memItemLeft" align="right" valign="top"><a id="a04ee2c697723438ceea05de698d99fc0" name="a04ee2c697723438ceea05de698d99fc0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MessageClientFilterPtr</b> = std::shared_ptr&lt; <a class="el" href="classtrpc_1_1_filter_3_01_client_context_ptr_01_4.html">MessageClientFilter</a> &gt;</td></tr>
<tr class="separator:a04ee2c697723438ceea05de698d99fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94945f98ebe0fbf599fe325430b96b9c" id="r_a94945f98ebe0fbf599fe325430b96b9c"><td class="memItemLeft" align="right" valign="top"><a id="a94945f98ebe0fbf599fe325430b96b9c" name="a94945f98ebe0fbf599fe325430b96b9c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FilterType</b> = <a class="el" href="namespacetrpc.html#a1acfffc3d3bd36f413b6360fad52002a">PluginType</a></td></tr>
<tr class="separator:a94945f98ebe0fbf599fe325430b96b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab918f998dee0bd262e869f06ada12f7e" id="r_ab918f998dee0bd262e869f06ada12f7e"><td class="memItemLeft" align="right" valign="top"><a id="ab918f998dee0bd262e869f06ada12f7e" name="ab918f998dee0bd262e869f06ada12f7e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MessageServerFilter</b> = <a class="el" href="classtrpc_1_1_filter.html">Filter</a>&lt; <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &gt;</td></tr>
<tr class="separator:ab918f998dee0bd262e869f06ada12f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a218a7992f5debf5a90ff7495c3164" id="r_af2a218a7992f5debf5a90ff7495c3164"><td class="memItemLeft" align="right" valign="top"><a id="af2a218a7992f5debf5a90ff7495c3164" name="af2a218a7992f5debf5a90ff7495c3164"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MessageServerFilterPtr</b> = std::shared_ptr&lt; <a class="el" href="classtrpc_1_1_filter_3_01_server_context_ptr_01_4.html">MessageServerFilter</a> &gt;</td></tr>
<tr class="separator:af2a218a7992f5debf5a90ff7495c3164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d7abc9d989fec10ec79faa9b481c59" id="r_a74d7abc9d989fec10ec79faa9b481c59"><td class="memItemLeft" align="right" valign="top"><a id="a74d7abc9d989fec10ec79faa9b481c59" name="a74d7abc9d989fec10ec79faa9b481c59"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LoggingPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_logging.html">Logging</a> &gt;</td></tr>
<tr class="separator:a74d7abc9d989fec10ec79faa9b481c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a91d0905513ebd4b7949e22a4a4efc4" id="r_a5a91d0905513ebd4b7949e22a4a4efc4"><td class="memItemLeft" align="right" valign="top"><a id="a5a91d0905513ebd4b7949e22a4a4efc4" name="a5a91d0905513ebd4b7949e22a4a4efc4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>HistogramBucket</b> = std::vector&lt; double &gt;</td></tr>
<tr class="memdesc:a5a91d0905513ebd4b7949e22a4a4efc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket for histogram statistics. <br /></td></tr>
<tr class="separator:a5a91d0905513ebd4b7949e22a4a4efc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dba4109f2c6df51221c244b9d8246a" id="r_ab5dba4109f2c6df51221c244b9d8246a"><td class="memItemLeft" align="right" valign="top"><a id="ab5dba4109f2c6df51221c244b9d8246a" name="ab5dba4109f2c6df51221c244b9d8246a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SummaryQuantiles</b> = std::vector&lt; std::vector&lt; double &gt; &gt;</td></tr>
<tr class="memdesc:ab5dba4109f2c6df51221c244b9d8246a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantiles for summary statistics. <br /></td></tr>
<tr class="separator:ab5dba4109f2c6df51221c244b9d8246a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758931ce51bac63e487e92d12594a724" id="r_a758931ce51bac63e487e92d12594a724"><td class="memItemLeft" align="right" valign="top"><a id="a758931ce51bac63e487e92d12594a724" name="a758931ce51bac63e487e92d12594a724"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MetricsPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_metrics.html">Metrics</a> &gt;</td></tr>
<tr class="separator:a758931ce51bac63e487e92d12594a724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f97a9f0052c682a844ea7f7da5f940" id="r_a87f97a9f0052c682a844ea7f7da5f940"><td class="memItemLeft" align="right" valign="top"><a id="a87f97a9f0052c682a844ea7f7da5f940" name="a87f97a9f0052c682a844ea7f7da5f940"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LimiterPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_limiter.html">Limiter</a> &gt;</td></tr>
<tr class="separator:a87f97a9f0052c682a844ea7f7da5f940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21e8bf3b9c5107be41e1b71532620a1" id="r_ac21e8bf3b9c5107be41e1b71532620a1"><td class="memItemLeft" align="right" valign="top"><a id="ac21e8bf3b9c5107be41e1b71532620a1" name="ac21e8bf3b9c5107be41e1b71532620a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LoadBalancePtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_load_balance.html">LoadBalance</a> &gt;</td></tr>
<tr class="separator:ac21e8bf3b9c5107be41e1b71532620a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5885673a820696aeb5273006ddf03af" id="r_ac5885673a820696aeb5273006ddf03af"><td class="memItemLeft" align="right" valign="top"><a id="ac5885673a820696aeb5273006ddf03af" name="ac5885673a820696aeb5273006ddf03af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RegistryPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_registry.html">Registry</a> &gt;</td></tr>
<tr class="separator:ac5885673a820696aeb5273006ddf03af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec0f4db48b87f9d98afde423771f404" id="r_a8ec0f4db48b87f9d98afde423771f404"><td class="memItemLeft" align="right" valign="top"><a id="a8ec0f4db48b87f9d98afde423771f404" name="a8ec0f4db48b87f9d98afde423771f404"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SelectorPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_selector.html">Selector</a> &gt;</td></tr>
<tr class="separator:a8ec0f4db48b87f9d98afde423771f404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8921aa1f842cf1dc4e68740b2a243f2b" id="r_a8921aa1f842cf1dc4e68740b2a243f2b"><td class="memTemplParams" colspan="2"><a id="a8921aa1f842cf1dc4e68740b2a243f2b" name="a8921aa1f842cf1dc4e68740b2a243f2b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8921aa1f842cf1dc4e68740b2a243f2b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_server_context</b> = std::is_same&lt; T, <a class="el" href="classtrpc_1_1_server_context.html">ServerContext</a> &gt;</td></tr>
<tr class="separator:a8921aa1f842cf1dc4e68740b2a243f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982afae1822d11f29ca961f90f050ce7" id="r_a982afae1822d11f29ca961f90f050ce7"><td class="memItemLeft" align="right" valign="top"><a id="a982afae1822d11f29ca961f90f050ce7" name="a982afae1822d11f29ca961f90f050ce7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>HandleRequestDispatcherFunction</b> = std::function&lt; int32_t(const STransportReqMsg *req)&gt;</td></tr>
<tr class="memdesc:a982afae1822d11f29ca961f90f050ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function for dispatching request to specified handle-thread generally used in merge and separate threading models. <br /></td></tr>
<tr class="separator:a982afae1822d11f29ca961f90f050ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ff73786436b6fac0cf4968f864df65" id="r_a86ff73786436b6fac0cf4968f864df65"><td class="memItemLeft" align="right" valign="top"><a id="a86ff73786436b6fac0cf4968f864df65" name="a86ff73786436b6fac0cf4968f864df65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ServiceTimeoutHandleFunction</b> = std::function&lt; void(const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;context)&gt;</td></tr>
<tr class="memdesc:a86ff73786436b6fac0cf4968f864df65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function for user-defined processing request after request timeout. <br /></td></tr>
<tr class="separator:a86ff73786436b6fac0cf4968f864df65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed89a8f2c555d5d47ef77e866a568468" id="r_aed89a8f2c555d5d47ef77e866a568468"><td class="memItemLeft" align="right" valign="top"><a id="aed89a8f2c555d5d47ef77e866a568468" name="aed89a8f2c555d5d47ef77e866a568468"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CustomSocketOptFunction</b> = SetSocketOptFunction</td></tr>
<tr class="memdesc:aed89a8f2c555d5d47ef77e866a568468"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function for user self-defined set socket option. <br /></td></tr>
<tr class="separator:aed89a8f2c555d5d47ef77e866a568468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a5810a0f183dd91beee8c0d06fa255" id="r_a16a5810a0f183dd91beee8c0d06fa255"><td class="memItemLeft" align="right" valign="top"><a id="a16a5810a0f183dd91beee8c0d06fa255" name="a16a5810a0f183dd91beee8c0d06fa255"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ServicePtr</b> = std::shared_ptr&lt; <a class="el" href="classtrpc_1_1_service.html">Service</a> &gt;</td></tr>
<tr class="separator:a16a5810a0f183dd91beee8c0d06fa255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac8f0a41169efffd59b6e977bb2e36f" id="r_a6ac8f0a41169efffd59b6e977bb2e36f"><td class="memItemLeft" align="right" valign="top"><a id="a6ac8f0a41169efffd59b6e977bb2e36f" name="a6ac8f0a41169efffd59b6e977bb2e36f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TelemetryPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_telemetry.html">Telemetry</a> &gt;</td></tr>
<tr class="separator:a6ac8f0a41169efffd59b6e977bb2e36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc8ccd788a059feaf32b0921d21e3b6" id="r_adfc8ccd788a059feaf32b0921d21e3b6"><td class="memItemLeft" align="right" valign="top"><a id="adfc8ccd788a059feaf32b0921d21e3b6" name="adfc8ccd788a059feaf32b0921d21e3b6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TracingPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_tracing.html">Tracing</a> &gt;</td></tr>
<tr class="separator:adfc8ccd788a059feaf32b0921d21e3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59f26bb9d380d806ebab71fcf7bb49d" id="r_ad59f26bb9d380d806ebab71fcf7bb49d"><td class="memItemLeft" align="right" valign="top"><a id="ad59f26bb9d380d806ebab71fcf7bb49d" name="ad59f26bb9d380d806ebab71fcf7bb49d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Buffer</b> = <a class="el" href="classtrpc_1_1_contiguous_buffer.html">ContiguousBuffer</a></td></tr>
<tr class="separator:ad59f26bb9d380d806ebab71fcf7bb49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30566e172a34beec5b79262649e49ebe" id="r_a30566e172a34beec5b79262649e49ebe"><td class="memItemLeft" align="right" valign="top"><a id="a30566e172a34beec5b79262649e49ebe" name="a30566e172a34beec5b79262649e49ebe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BufferPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_contiguous_buffer.html">Buffer</a> &gt;</td></tr>
<tr class="separator:a30566e172a34beec5b79262649e49ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6945b1e354ac7b39824c3b1c6ea0918c" id="r_a6945b1e354ac7b39824c3b1c6ea0918c"><td class="memItemLeft" align="right" valign="top"><a id="a6945b1e354ac7b39824c3b1c6ea0918c" name="a6945b1e354ac7b39824c3b1c6ea0918c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MQThreadPoolTaskFunc</b> = <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt;</td></tr>
<tr class="separator:a6945b1e354ac7b39824c3b1c6ea0918c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5ad7336c41ca31a67dcfe2fddd1d07" id="r_a7b5ad7336c41ca31a67dcfe2fddd1d07"><td class="memItemLeft" align="right" valign="top"><a id="a7b5ad7336c41ca31a67dcfe2fddd1d07" name="a7b5ad7336c41ca31a67dcfe2fddd1d07"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadLock</b> = <a class="el" href="classtrpc_1_1_thread_monitor.html">ThreadMonitor</a>&lt; <a class="el" href="classtrpc_1_1_thread_mutex.html">ThreadMutex</a>, <a class="el" href="classtrpc_1_1_thread_cond.html">ThreadCond</a> &gt;</td></tr>
<tr class="separator:a7b5ad7336c41ca31a67dcfe2fddd1d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cd35dce5dd1d10500130206a0dda9b" id="r_a99cd35dce5dd1d10500130206a0dda9b"><td class="memItemLeft" align="right" valign="top"><a id="a99cd35dce5dd1d10500130206a0dda9b" name="a99cd35dce5dd1d10500130206a0dda9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadRecLock</b> = <a class="el" href="classtrpc_1_1_thread_monitor.html">ThreadMonitor</a>&lt; <a class="el" href="classtrpc_1_1_thread_rec_mutex.html">ThreadRecMutex</a>, <a class="el" href="classtrpc_1_1_thread_cond.html">ThreadCond</a> &gt;</td></tr>
<tr class="separator:a99cd35dce5dd1d10500130206a0dda9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8a9d1873dbfa932931cc1add10e58d" id="r_a3a8a9d1873dbfa932931cc1add10e58d"><td class="memItemLeft" align="right" valign="top"><a id="a3a8a9d1873dbfa932931cc1add10e58d" name="a3a8a9d1873dbfa932931cc1add10e58d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadPool</b> = <a class="el" href="classtrpc_1_1_thread_pool_impl.html">ThreadPoolImpl</a>&lt; <a class="el" href="classtrpc_1_1_s_q_thread_pool.html">SQThreadPool</a> &gt;</td></tr>
<tr class="separator:a3a8a9d1873dbfa932931cc1add10e58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9a7254e8cd901863b72eb96156777f" id="r_a7f9a7254e8cd901863b72eb96156777f"><td class="memItemLeft" align="right" valign="top"><a id="a7f9a7254e8cd901863b72eb96156777f" name="a7f9a7254e8cd901863b72eb96156777f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LogPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_log.html">Log</a> &gt;</td></tr>
<tr class="separator:a7f9a7254e8cd901863b72eb96156777f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db8371cfb7aed8070a08dcd81245fbc" id="r_a6db8371cfb7aed8070a08dcd81245fbc"><td class="memItemLeft" align="right" valign="top"><a id="a6db8371cfb7aed8070a08dcd81245fbc" name="a6db8371cfb7aed8070a08dcd81245fbc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultLogPtr</b> = <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="classtrpc_1_1_default_log.html">DefaultLog</a> &gt;</td></tr>
<tr class="separator:a6db8371cfb7aed8070a08dcd81245fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4c282f7cd328ad548d2a50ec3ee0874b" id="r_a4c282f7cd328ad548d2a50ec3ee0874b"><td class="memItemLeft" align="right" valign="top"><a id="a4c282f7cd328ad548d2a50ec3ee0874b" name="a4c282f7cd328ad548d2a50ec3ee0874b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EncodeType</b> { <br />
&#160;&#160;<b>PB</b> = TrpcContentEncodeType::TRPC_PROTO_ENCODE
, <b>JCE</b> = TrpcContentEncodeType::TRPC_JCE_ENCODE
, <b>JSON</b> = TrpcContentEncodeType::TRPC_JSON_ENCODE
, <b>FLATBUFFER</b> = TrpcContentEncodeType::TRPC_FLATBUFFER_ENCODE
, <br />
&#160;&#160;<b>NOOP</b> = TrpcContentEncodeType::TRPC_NOOP_ENCODE
, <b>THRIFT</b> = TrpcContentEncodeType::TRPC_THRIFT_ENCODE
, <b>MAX_TYPE</b> = 255
<br />
 }</td></tr>
<tr class="separator:a4c282f7cd328ad548d2a50ec3ee0874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acfffc3d3bd36f413b6360fad52002a" id="r_a1acfffc3d3bd36f413b6360fad52002a"><td class="memItemLeft" align="right" valign="top"><a id="a1acfffc3d3bd36f413b6360fad52002a" name="a1acfffc3d3bd36f413b6360fad52002a"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a1acfffc3d3bd36f413b6360fad52002a">PluginType</a> { <br />
&#160;&#160;<b>kRegistry</b>
, <b>kSelector</b>
, <b>kDiscovery</b>
, <b>kLoadbalance</b>
, <br />
&#160;&#160;<b>kCircuitbreaker</b>
, <b>kLimiter</b>
, <b>kConfig</b>
, <b>kConfigProvider</b>
, <br />
&#160;&#160;<b>kConfigCodec</b>
, <b>kMetrics</b>
, <b>kTracing</b>
, <b>kTelemetry</b>
, <br />
&#160;&#160;<b>kAuth</b>
, <b>kAuthCenterFollower</b>
, <b>kLogging</b>
, <b>kUnspecified</b>
<br />
 }</td></tr>
<tr class="memdesc:a1acfffc3d3bd36f413b6360fad52002a"><td class="mdescLeft">&#160;</td><td class="mdescRight">all plugin type <br /></td></tr>
<tr class="separator:a1acfffc3d3bd36f413b6360fad52002a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2843836703e68d6a142b786a0876023" id="r_ad2843836703e68d6a142b786a0876023"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ad2843836703e68d6a142b786a0876023">FilterStatus</a> { <a class="el" href="namespacetrpc.html#ad2843836703e68d6a142b786a0876023a2f453cfe638e57e27bb0c9512436111e">CONTINUE</a> = 0
, <a class="el" href="namespacetrpc.html#ad2843836703e68d6a142b786a0876023a59b228d9fec9b88833bfe5d812ed8ad4">REJECT</a> = 1
 }</td></tr>
<tr class="memdesc:ad2843836703e68d6a142b786a0876023"><td class="mdescLeft">&#160;</td><td class="mdescRight">filter execution status  <a href="namespacetrpc.html#ad2843836703e68d6a142b786a0876023">More...</a><br /></td></tr>
<tr class="separator:ad2843836703e68d6a142b786a0876023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ad6719274d32670d65731183e4db12" id="r_a30ad6719274d32670d65731183e4db12"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12">FilterPoint</a> { <br />
&#160;&#160;<a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12a468638263772223935d19ee323991d00">CLIENT_PRE_RPC_INVOKE</a> = 0
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12a9e70d6ca9b4d13184e73eff303cfbeab">CLIENT_POST_RPC_INVOKE</a> = 1
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12acc68a7448829d47b0c939713220799dd">CLIENT_PRE_SEND_MSG</a> = 2
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12aeaaca82fa04a0b6906b6c0e752f17f22">CLIENT_POST_RECV_MSG</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12a7d8556bd1a2d98d38f550472503a3ee7">CLIENT_PRE_SCHED_SEND_MSG</a> = 4
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12aeabbe66a61b0f99dd77b2d3b464dc27d">CLIENT_POST_SCHED_SEND_MSG</a> = 5
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12aab5281da4996c5e2a4c77a8f8d15e1f1">CLIENT_PRE_SCHED_RECV_MSG</a> = 6
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12a89019049366801d06a98a5c6ab548cff">CLIENT_POST_SCHED_RECV_MSG</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12aa93b97fed9510562ec49f8034c014f2b">CLIENT_PRE_IO_SEND_MSG</a> = 8
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12ab9d702e318c326da14b1d857c9200475">CLIENT_POST_IO_SEND_MSG</a> = 9
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12abd6fd09897fa541f57659891b4f359b4">SERVER_POST_RECV_MSG</a> = kServerFilterPrefix | 0
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12a43eb2a4cf2dc6fb7aa813a31a1d43d91">SERVER_PRE_SEND_MSG</a> = kServerFilterPrefix | 1
, <br />
&#160;&#160;<a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12a6ec0fc1b12fa10e3f532be796a73b66e">SERVER_PRE_RPC_INVOKE</a> = kServerFilterPrefix | 2
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12a2fa2a8126a608a5adae5baacf51aebee">SERVER_POST_RPC_INVOKE</a> = kServerFilterPrefix | 3
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12ab325e9e3e9b815bc2180b40f010abd0d">SERVER_PRE_SCHED_RECV_MSG</a> = kServerFilterPrefix | 4
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12ade4430aabf079624c2d4a98bae8aa934">SERVER_POST_SCHED_RECV_MSG</a> = kServerFilterPrefix | 5
, <br />
&#160;&#160;<a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12a7779da133e794f9f5adf0cc68e5c79c5">SERVER_PRE_SCHED_SEND_MSG</a> = kServerFilterPrefix | 6
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12a409fd855750b4f3b9b23350aa9b281a9">SERVER_POST_SCHED_SEND_MSG</a> = kServerFilterPrefix | 7
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12ada27b10ff257bdf112b0b856f9e105ad">SERVER_PRE_IO_SEND_MSG</a> = kServerFilterPrefix | 8
, <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12aadff508c04f22a3a5046e149b2cbd004">SERVER_POST_IO_SEND_MSG</a> = kServerFilterPrefix | 9
<br />
 }</td></tr>
<tr class="memdesc:a30ad6719274d32670d65731183e4db12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of filter points : including pre and post filter points (there are paired).  <a href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12">More...</a><br /></td></tr>
<tr class="separator:a30ad6719274d32670d65731183e4db12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aabc4f119fc1b5de072cd27136d33b4" id="r_a0aabc4f119fc1b5de072cd27136d33b4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4">MetricsPolicy</a> { <br />
&#160;&#160;<a class="el" href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4a838eb9b41ff3af23778d6dc81153a296">SET</a> = 0
, <a class="el" href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4a299005135f31b7fee9e679d24f13c0d3">SUM</a> = 1
, <a class="el" href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4a1d2fc85492c4e0f335d9a0638d0074e9">AVG</a> = 2
, <a class="el" href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4ae8bc50fb111ced7281df896367feccb9">MAX</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4a1e4f2700a908ecb0196b0e55aa130528">MIN</a> = 4
, <a class="el" href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4a33376d99579f3a1214ffde85c963364f">MID</a> = 5
, <a class="el" href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4adac8002e407d444f0e453d3a77eeced9">QUANTILES</a> = 6
, <a class="el" href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4ac7f2951ad3416d306e490f79ce2b5c1d">HISTOGRAM</a> = 7
<br />
 }</td></tr>
<tr class="memdesc:a0aabc4f119fc1b5de072cd27136d33b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistical strategy.  <a href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4">More...</a><br /></td></tr>
<tr class="separator:a0aabc4f119fc1b5de072cd27136d33b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac475587e42e2de2bba3fb22ab3455999" id="r_ac475587e42e2de2bba3fb22ab3455999"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ac475587e42e2de2bba3fb22ab3455999">SelectorPolicy</a> { <br />
&#160;&#160;<a class="el" href="namespacetrpc.html#ac475587e42e2de2bba3fb22ab3455999abc21e6484530fc9d0313cb816b733396">ONE</a>
, <a class="el" href="namespacetrpc.html#ac475587e42e2de2bba3fb22ab3455999a5fb1f955b45e38e31789286a1790398d">ALL</a>
, <a class="el" href="namespacetrpc.html#ac475587e42e2de2bba3fb22ab3455999a8c52684db8f49511e9b44471716bf164">SET</a>
, <a class="el" href="namespacetrpc.html#ac475587e42e2de2bba3fb22ab3455999a0dfcc4a2577af287e948561de2e93e0e">IDC</a>
, <br />
&#160;&#160;<a class="el" href="namespacetrpc.html#ac475587e42e2de2bba3fb22ab3455999a65f405ff27981239b3c296a487786b85">MULTIPLE</a>
<br />
 }</td></tr>
<tr class="memdesc:ac475587e42e2de2bba3fb22ab3455999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routing selection policy.  <a href="namespacetrpc.html#ac475587e42e2de2bba3fb22ab3455999">More...</a><br /></td></tr>
<tr class="separator:ac475587e42e2de2bba3fb22ab3455999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a27838d5faa6ad90bb041fb7aeded5c" id="r_a1a27838d5faa6ad90bb041fb7aeded5c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a1a27838d5faa6ad90bb041fb7aeded5c">LimitRetCode</a> { <a class="el" href="namespacetrpc.html#a1a27838d5faa6ad90bb041fb7aeded5cac324442010758817b56071603c9114a2">kLimitOK</a> = 0
, <a class="el" href="namespacetrpc.html#a1a27838d5faa6ad90bb041fb7aeded5ca11edb94b73657cb828be90b8aea80101">kLimitError</a>
, <a class="el" href="namespacetrpc.html#a1a27838d5faa6ad90bb041fb7aeded5ca730e524ed3269bc7351eb1dae327d24b">kLimitReject</a>
 }</td></tr>
<tr class="memdesc:a1a27838d5faa6ad90bb041fb7aeded5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return codes of rate limiting interface.  <a href="namespacetrpc.html#a1a27838d5faa6ad90bb041fb7aeded5c">More...</a><br /></td></tr>
<tr class="separator:a1a27838d5faa6ad90bb041fb7aeded5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a15f95a27a3dc0d0c5334abdffb399c16" id="r_a15f95a27a3dc0d0c5334abdffb399c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a15f95a27a3dc0d0c5334abdffb399c16">MakeClientContext</a> (const ServiceProxyPtr &amp;proxy)</td></tr>
<tr class="memdesc:a15f95a27a3dc0d0c5334abdffb399c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create client context based on service proxy(for rpc).  <br /></td></tr>
<tr class="separator:a15f95a27a3dc0d0c5334abdffb399c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ce0689e2fce11a2528f5803fe69025" id="r_a59ce0689e2fce11a2528f5803fe69025"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a59ce0689e2fce11a2528f5803fe69025">MakeClientContext</a> (const ServiceProxyPtr &amp;proxy, const ProtocolPtr &amp;req, const ProtocolPtr &amp;rsp)</td></tr>
<tr class="memdesc:a59ce0689e2fce11a2528f5803fe69025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create client context based on service proxy(for non-rpc).  <br /></td></tr>
<tr class="separator:a59ce0689e2fce11a2528f5803fe69025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87706fce956605f16313beb49302411a" id="r_a87706fce956605f16313beb49302411a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a87706fce956605f16313beb49302411a">MakeClientContext</a> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;ctx, const ServiceProxyPtr &amp;proxy, bool with_trans_info=true)</td></tr>
<tr class="memdesc:a87706fce956605f16313beb49302411a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create client context based on server context and service proxy(for rpc).  <br /></td></tr>
<tr class="separator:a87706fce956605f16313beb49302411a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b8fe157dcbfcacf089fc4ccdd0e5d1" id="r_a80b8fe157dcbfcacf089fc4ccdd0e5d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a80b8fe157dcbfcacf089fc4ccdd0e5d1">MakeClientContext</a> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;ctx, const ServiceProxyPtr &amp;proxy, const ProtocolPtr &amp;req, const ProtocolPtr &amp;rsp, bool with_trans_info=true)</td></tr>
<tr class="memdesc:a80b8fe157dcbfcacf089fc4ccdd0e5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create client context based on server context and service proxy(for non-rpc).  <br /></td></tr>
<tr class="separator:a80b8fe157dcbfcacf089fc4ccdd0e5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc909f5279f4ebcf092a4c290c9baa1d" id="r_afc909f5279f4ebcf092a4c290c9baa1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#afc909f5279f4ebcf092a4c290c9baa1d">MakeTransparentClientContext</a> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;ctx, const ServiceProxyPtr &amp;proxy)</td></tr>
<tr class="memdesc:afc909f5279f4ebcf092a4c290c9baa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create client context for transparent transmission.  <br /></td></tr>
<tr class="separator:afc909f5279f4ebcf092a4c290c9baa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283fc1da9109c60e49af359fa39f8068" id="r_a283fc1da9109c60e49af359fa39f8068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a283fc1da9109c60e49af359fa39f8068">BackFillServerTransInfo</a> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;client_context, const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;server_context)</td></tr>
<tr class="memdesc:a283fc1da9109c60e49af359fa39f8068"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the scenario of a route service, obtain the transparent transmission information replied by the backend node, fill it back to the relay service, and then return it to the frontend node by the relay service.  <br /></td></tr>
<tr class="separator:a283fc1da9109c60e49af359fa39f8068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee7ff5830936877199eac98e749dc73" id="r_a8ee7ff5830936877199eac98e749dc73"><td class="memItemLeft" align="right" valign="top"><a id="a8ee7ff5830936877199eac98e749dc73" name="a8ee7ff5830936877199eac98e749dc73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterMakeClientContextCallback</b> (<a class="el" href="namespacetrpc.html#a110a4d0f8a2121d80262036f4eb57333">MakeClientContextCallback</a> &amp;&amp;callback)</td></tr>
<tr class="separator:a8ee7ff5830936877199eac98e749dc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aec852909d2777984b80717f0b6afd" id="r_a60aec852909d2777984b80717f0b6afd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtrpc_1_1_trpc_client.html">TrpcClient</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a60aec852909d2777984b80717f0b6afd">GetTrpcClient</a> ()</td></tr>
<tr class="memdesc:a60aec852909d2777984b80717f0b6afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global <a class="el" href="classtrpc_1_1_trpc_client.html" title="Implementation of trpc client.">TrpcClient</a>.  <br /></td></tr>
<tr class="separator:a60aec852909d2777984b80717f0b6afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a71e6f23f6fb89fe17288b5ab8997ec" id="r_a3a71e6f23f6fb89fe17288b5ab8997ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a3a71e6f23f6fb89fe17288b5ab8997ec">RunInTrpcRuntime</a> (std::function&lt; int()&gt; &amp;&amp;func)</td></tr>
<tr class="memdesc:a3a71e6f23f6fb89fe17288b5ab8997ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The entry function for the pure client program runs in trpc(fiber/merge/separate) runtime.  <br /></td></tr>
<tr class="separator:a3a71e6f23f6fb89fe17288b5ab8997ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95544b09724701bc083c325f1195cb49" id="r_a95544b09724701bc083c325f1195cb49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a95544b09724701bc083c325f1195cb49">RunInFiberRuntime</a> (std::function&lt; int()&gt; &amp;&amp;func)</td></tr>
<tr class="memdesc:a95544b09724701bc083c325f1195cb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">The entry function for the pure client program runs in fiber runtime.  <br /></td></tr>
<tr class="separator:a95544b09724701bc083c325f1195cb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad67a015c2a1afaad7ab04b91702525d" id="r_aad67a015c2a1afaad7ab04b91702525d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#aad67a015c2a1afaad7ab04b91702525d">RunInThreadRuntime</a> (std::function&lt; int()&gt; &amp;&amp;func)</td></tr>
<tr class="memdesc:aad67a015c2a1afaad7ab04b91702525d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The entry function for the pure client program runs in thread(merge/separate) runtime.  <br /></td></tr>
<tr class="separator:aad67a015c2a1afaad7ab04b91702525d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e50bad0b39f8b2d57dac348514cc704" id="r_a1e50bad0b39f8b2d57dac348514cc704"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a1e50bad0b39f8b2d57dac348514cc704">StartFiberDetached</a> (<a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &amp;&amp;start_proc)</td></tr>
<tr class="memdesc:a1e50bad0b39f8b2d57dac348514cc704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fiber and run it.  <br /></td></tr>
<tr class="separator:a1e50bad0b39f8b2d57dac348514cc704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0b460dc2fe808c9fbe4f4753a1b5ed" id="r_aac0b460dc2fe808c9fbe4f4753a1b5ed"><td class="memItemLeft" align="right" valign="top"><a id="aac0b460dc2fe808c9fbe4f4753a1b5ed" name="aac0b460dc2fe808c9fbe4f4753a1b5ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StartFiberDetached</b> (<a class="el" href="structtrpc_1_1_fiber_1_1_attributes.html">Fiber::Attributes</a> &amp;&amp;attrs, <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &amp;&amp;start_proc)</td></tr>
<tr class="memdesc:aac0b460dc2fe808c9fbe4f4753a1b5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fiber by attrs and run it. <br /></td></tr>
<tr class="separator:aac0b460dc2fe808c9fbe4f4753a1b5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da1c8975bef8d8d483c4cfe0cde9ccc" id="r_a9da1c8975bef8d8d483c4cfe0cde9ccc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a9da1c8975bef8d8d483c4cfe0cde9ccc">BatchStartFiberDetached</a> (std::vector&lt; <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &gt; &amp;&amp;start_procs)</td></tr>
<tr class="memdesc:a9da1c8975bef8d8d483c4cfe0cde9ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batch Create fibers and run all.  <br /></td></tr>
<tr class="separator:a9da1c8975bef8d8d483c4cfe0cde9ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039d231c805f5660aaf16bb898e4d77e" id="r_a039d231c805f5660aaf16bb898e4d77e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a039d231c805f5660aaf16bb898e4d77e">FiberYield</a> ()</td></tr>
<tr class="memdesc:a039d231c805f5660aaf16bb898e4d77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield execution.  <br /></td></tr>
<tr class="separator:a039d231c805f5660aaf16bb898e4d77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a5373cea48f3f2edfb53b0de55ea80" id="r_a31a5373cea48f3f2edfb53b0de55ea80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a31a5373cea48f3f2edfb53b0de55ea80">FiberSleepUntil</a> (const std::chrono::steady_clock::time_point &amp;expires_at)</td></tr>
<tr class="memdesc:a31a5373cea48f3f2edfb53b0de55ea80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block calling pthread or calling fiber until <code>expires_at</code>.  <br /></td></tr>
<tr class="separator:a31a5373cea48f3f2edfb53b0de55ea80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c4582fef555fe7dab66477314f8644" id="r_af4c4582fef555fe7dab66477314f8644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#af4c4582fef555fe7dab66477314f8644">FiberSleepFor</a> (const std::chrono::nanoseconds &amp;expires_in)</td></tr>
<tr class="memdesc:af4c4582fef555fe7dab66477314f8644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block calling pthread or calling fiber for <code>expires_in</code>.  <br /></td></tr>
<tr class="separator:af4c4582fef555fe7dab66477314f8644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cfb2a8dbb0c6a02a7b19df319648b2" id="r_af3cfb2a8dbb0c6a02a7b19df319648b2"><td class="memTemplParams" colspan="2">template&lt;class Clock , class Duration &gt; </td></tr>
<tr class="memitem:af3cfb2a8dbb0c6a02a7b19df319648b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#af3cfb2a8dbb0c6a02a7b19df319648b2">FiberSleepUntil</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;expires_at)</td></tr>
<tr class="memdesc:af3cfb2a8dbb0c6a02a7b19df319648b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>SleepUntil</code> for clocks other than <code>std::steady_clock</code>.  <br /></td></tr>
<tr class="separator:af3cfb2a8dbb0c6a02a7b19df319648b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607ab3e196e71cd65dddf61bff7993d1" id="r_a607ab3e196e71cd65dddf61bff7993d1"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a607ab3e196e71cd65dddf61bff7993d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a607ab3e196e71cd65dddf61bff7993d1">FiberSleepFor</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;expires_in)</td></tr>
<tr class="memdesc:a607ab3e196e71cd65dddf61bff7993d1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>SleepFor</code> for durations other than <code>std::chrono::nanoseconds</code>.  <br /></td></tr>
<tr class="separator:a607ab3e196e71cd65dddf61bff7993d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2a2ef87f461f20ffa2eeb9ad36a0e6" id="r_a1d2a2ef87f461f20ffa2eeb9ad36a0e6"><td class="memItemLeft" align="right" valign="top"><a id="a1d2a2ef87f461f20ffa2eeb9ad36a0e6" name="a1d2a2ef87f461f20ffa2eeb9ad36a0e6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsRunningInFiberWorker</b> ()</td></tr>
<tr class="memdesc:a1d2a2ef87f461f20ffa2eeb9ad36a0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the currently running thread is a fiber worker thread. <br /></td></tr>
<tr class="separator:a1d2a2ef87f461f20ffa2eeb9ad36a0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7cc06c7d80e2360e176fc1770d444b" id="r_acb7cc06c7d80e2360e176fc1770d444b"><td class="memItemLeft" align="right" valign="top"><a id="acb7cc06c7d80e2360e176fc1770d444b" name="acb7cc06c7d80e2360e176fc1770d444b"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetFiberCount</b> ()</td></tr>
<tr class="memdesc:acb7cc06c7d80e2360e176fc1770d444b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classtrpc_1_1_fiber.html" title="Analogous to std::thread, but it&#39;s for fiber.">Fiber</a> Count . <br /></td></tr>
<tr class="separator:acb7cc06c7d80e2360e176fc1770d444b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96287f3404edb677e8591fe13d7529e" id="r_ad96287f3404edb677e8591fe13d7529e"><td class="memItemLeft" align="right" valign="top"><a id="ad96287f3404edb677e8591fe13d7529e" name="ad96287f3404edb677e8591fe13d7529e"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetFiberQueueSize</b> ()</td></tr>
<tr class="memdesc:ad96287f3404edb677e8591fe13d7529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the fibers that all be waiting to running in the run queue. <br /></td></tr>
<tr class="separator:ad96287f3404edb677e8591fe13d7529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41deb8e29150d75353ff6a4b91d88d66" id="r_a41deb8e29150d75353ff6a4b91d88d66"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a41deb8e29150d75353ff6a4b91d88d66">SetFiberTimer</a> (std::chrono::steady_clock::time_point at, <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &amp;&amp;cb)</td></tr>
<tr class="memdesc:a41deb8e29150d75353ff6a4b91d88d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a one-shot timer.  <br /></td></tr>
<tr class="separator:a41deb8e29150d75353ff6a4b91d88d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863f931fb7c43402bfd8c256b18f3e24" id="r_a863f931fb7c43402bfd8c256b18f3e24"><td class="memItemLeft" align="right" valign="top"><a id="a863f931fb7c43402bfd8c256b18f3e24" name="a863f931fb7c43402bfd8c256b18f3e24"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>SetFiberTimer</b> (std::chrono::steady_clock::time_point at, <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void(std::uint64_t)&gt; &amp;&amp;cb)</td></tr>
<tr class="separator:a863f931fb7c43402bfd8c256b18f3e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c95295e70e9a5b4ca522314960e9ff" id="r_a63c95295e70e9a5b4ca522314960e9ff"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a63c95295e70e9a5b4ca522314960e9ff">SetFiberTimer</a> (std::chrono::steady_clock::time_point at, std::chrono::nanoseconds interval, <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &amp;&amp;cb)</td></tr>
<tr class="memdesc:a63c95295e70e9a5b4ca522314960e9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a periodic timer.  <br /></td></tr>
<tr class="separator:a63c95295e70e9a5b4ca522314960e9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f0d6540f5641a695c7e393b2fa6733" id="r_a57f0d6540f5641a695c7e393b2fa6733"><td class="memItemLeft" align="right" valign="top"><a id="a57f0d6540f5641a695c7e393b2fa6733" name="a57f0d6540f5641a695c7e393b2fa6733"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>SetFiberTimer</b> (std::chrono::steady_clock::time_point at, std::chrono::nanoseconds interval, <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void(std::uint64_t)&gt; &amp;&amp;cb)</td></tr>
<tr class="separator:a57f0d6540f5641a695c7e393b2fa6733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e0e976c49d870f55de227d3875aff" id="r_a227e0e976c49d870f55de227d3875aff"><td class="memItemLeft" align="right" valign="top"><a id="a227e0e976c49d870f55de227d3875aff" name="a227e0e976c49d870f55de227d3875aff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DetachFiberTimer</b> (std::uint64_t timer_id)</td></tr>
<tr class="memdesc:a227e0e976c49d870f55de227d3875aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach <code>timer_id</code> without actually killing the timer. <br /></td></tr>
<tr class="separator:a227e0e976c49d870f55de227d3875aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f27aaffb1a7a38dcfb432be17cb2e30" id="r_a9f27aaffb1a7a38dcfb432be17cb2e30"><td class="memItemLeft" align="right" valign="top"><a id="a9f27aaffb1a7a38dcfb432be17cb2e30" name="a9f27aaffb1a7a38dcfb432be17cb2e30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFiberDetachedTimer</b> (std::chrono::steady_clock::time_point at, <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &amp;&amp;cb)</td></tr>
<tr class="separator:a9f27aaffb1a7a38dcfb432be17cb2e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5974391af1a6138ef28f1ed327a068e4" id="r_a5974391af1a6138ef28f1ed327a068e4"><td class="memItemLeft" align="right" valign="top"><a id="a5974391af1a6138ef28f1ed327a068e4" name="a5974391af1a6138ef28f1ed327a068e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFiberDetachedTimer</b> (std::chrono::steady_clock::time_point at, std::chrono::nanoseconds interval, <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &amp;&amp;cb)</td></tr>
<tr class="separator:a5974391af1a6138ef28f1ed327a068e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad757c37e30d4cce7c50e147b905664fb" id="r_ad757c37e30d4cce7c50e147b905664fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ad757c37e30d4cce7c50e147b905664fb">KillFiberTimer</a> (std::uint64_t timer_id)</td></tr>
<tr class="memdesc:ad757c37e30d4cce7c50e147b905664fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop timer.  <br /></td></tr>
<tr class="separator:ad757c37e30d4cce7c50e147b905664fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfe3315fa875dd98a4a65e114ba2cd2" id="r_a2bfe3315fa875dd98a4a65e114ba2cd2"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a2bfe3315fa875dd98a4a65e114ba2cd2">CreateFiberTimer</a> (std::chrono::steady_clock::time_point at, <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void(std::uint64_t)&gt; &amp;&amp;cb)</td></tr>
<tr class="memdesc:a2bfe3315fa875dd98a4a65e114ba2cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-stage timer creation, For internal use only.  <br /></td></tr>
<tr class="separator:a2bfe3315fa875dd98a4a65e114ba2cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8d503a4f1b3411177931913a06d45a" id="r_adf8d503a4f1b3411177931913a06d45a"><td class="memItemLeft" align="right" valign="top"><a id="adf8d503a4f1b3411177931913a06d45a" name="adf8d503a4f1b3411177931913a06d45a"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>CreateFiberTimer</b> (std::chrono::steady_clock::time_point at, std::chrono::nanoseconds interval, <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void(std::uint64_t)&gt; &amp;&amp;cb)</td></tr>
<tr class="separator:adf8d503a4f1b3411177931913a06d45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0735ceb246ba673813630b8057d25cbb" id="r_a0735ceb246ba673813630b8057d25cbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a0735ceb246ba673813630b8057d25cbb">EnableFiberTimer</a> (std::uint64_t timer_id)</td></tr>
<tr class="memdesc:a0735ceb246ba673813630b8057d25cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable timer previously created via <code>CreateFiberTimer</code>.  <br /></td></tr>
<tr class="separator:a0735ceb246ba673813630b8057d25cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4ac3db7bc11a9eac4e180e99a2f066" id="r_a2a4ac3db7bc11a9eac4e180e99a2f066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12">FilterPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a2a4ac3db7bc11a9eac4e180e99a2f066">GetMatchPoint</a> (<a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12">FilterPoint</a> point)</td></tr>
<tr class="memdesc:a2a4ac3db7bc11a9eac4e180e99a2f066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the paired filter point.  <br /></td></tr>
<tr class="separator:a2a4ac3db7bc11a9eac4e180e99a2f066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b0de13233394e627f7d398e0b246e9" id="r_a87b0de13233394e627f7d398e0b246e9"><td class="memTemplParams" colspan="2"><a id="a87b0de13233394e627f7d398e0b246e9" name="a87b0de13233394e627f7d398e0b246e9"></a>
template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a87b0de13233394e627f7d398e0b246e9"><td class="memTemplItemLeft" align="right" valign="top">Future&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeReadyFuture</b> (T &amp;&amp;... v)</td></tr>
<tr class="memdesc:a87b0de13233394e627f7d398e0b246e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a ready future with value set by parameter v. <br /></td></tr>
<tr class="separator:a87b0de13233394e627f7d398e0b246e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d98bea6174f8701d40220002afdad6" id="r_a66d98bea6174f8701d40220002afdad6"><td class="memTemplParams" colspan="2"><a id="a66d98bea6174f8701d40220002afdad6" name="a66d98bea6174f8701d40220002afdad6"></a>
template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a66d98bea6174f8701d40220002afdad6"><td class="memTemplItemLeft" align="right" valign="top">Future&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeExceptionFuture</b> (const <a class="el" href="classtrpc_1_1_exception.html">Exception</a> &amp;e)</td></tr>
<tr class="memdesc:a66d98bea6174f8701d40220002afdad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a exceptional future with exception set parameter e. <br /></td></tr>
<tr class="separator:a66d98bea6174f8701d40220002afdad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e1af894652159a23f334862ec13cd3" id="r_ae5e1af894652159a23f334862ec13cd3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Func , typename R  = typename std::invoke_result&lt;Func, T &amp;&gt;::type&gt; </td></tr>
<tr class="memitem:ae5e1af894652159a23f334862ec13cd3"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ae5e1af894652159a23f334862ec13cd3">DoWith</a> (T &amp;&amp;value, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:ae5e1af894652159a23f334862ec13cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a object to heap memory, and hold it until func's future was resolved.  <br /></td></tr>
<tr class="separator:ae5e1af894652159a23f334862ec13cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671550f90c6358589f3fa90ac5790c76" id="r_a671550f90c6358589f3fa90ac5790c76"><td class="memTemplParams" colspan="2">template&lt;typename Stop , typename Func , typename R  = std::invoke_result_t&lt;Func&gt;, typename  = std::enable_if_t&lt;std::is_same_v&lt;std::invoke_result_t&lt;Stop&gt;, bool&gt;&gt;, typename  = std::enable_if_t&lt;is_future_v&lt;R&gt;&gt;&gt; </td></tr>
<tr class="memitem:a671550f90c6358589f3fa90ac5790c76"><td class="memTemplItemLeft" align="right" valign="top">Future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a671550f90c6358589f3fa90ac5790c76">DoUntil</a> (Stop &amp;&amp;stop, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a671550f90c6358589f3fa90ac5790c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute func repeatedly until stop function return true.  <br /></td></tr>
<tr class="separator:a671550f90c6358589f3fa90ac5790c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9608847223f2ae284b6f6de062aa6e" id="r_a6f9608847223f2ae284b6f6de062aa6e"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename  = std::enable_if_t&lt;std::is_same_v&lt;std::invoke_result_t&lt;Func&gt;, Future&lt;bool&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a6f9608847223f2ae284b6f6de062aa6e"><td class="memTemplItemLeft" align="right" valign="top">Future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a6f9608847223f2ae284b6f6de062aa6e">DoUntil</a> (Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a6f9608847223f2ae284b6f6de062aa6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute func repeatedly until function return a ready Future&lt;bool&gt; with false.  <br /></td></tr>
<tr class="separator:a6f9608847223f2ae284b6f6de062aa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0dc6c107683d6ba75ea4f6ab513d7b" id="r_acb0dc6c107683d6ba75ea4f6ab513d7b"><td class="memTemplParams" colspan="2">template&lt;typename Condition , typename Func , typename R  = typename std::invoke_result_t&lt;Func&gt;, typename  = std::enable_if_t&lt;std::is_same_v&lt;std::invoke_result_t&lt;Condition&gt;, bool&gt;&gt;, typename  = std::enable_if_t&lt;is_future_v&lt;R&gt;&gt;&gt; </td></tr>
<tr class="memitem:acb0dc6c107683d6ba75ea4f6ab513d7b"><td class="memTemplItemLeft" align="right" valign="top">Future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#acb0dc6c107683d6ba75ea4f6ab513d7b">DoWhile</a> (Condition &amp;&amp;cond, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:acb0dc6c107683d6ba75ea4f6ab513d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute func repeatedly while cond function return true.  <br /></td></tr>
<tr class="separator:acb0dc6c107683d6ba75ea4f6ab513d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f062046bb92ea512eeb0653ccce116" id="r_a73f062046bb92ea512eeb0653ccce116"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename R  = std::invoke_result_t&lt;Func&gt;&gt; </td></tr>
<tr class="memitem:a73f062046bb92ea512eeb0653ccce116"><td class="memTemplItemLeft" align="right" valign="top">Future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a73f062046bb92ea512eeb0653ccce116">Repeat</a> (Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a73f062046bb92ea512eeb0653ccce116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute func repeatedly forever.  <br /></td></tr>
<tr class="separator:a73f062046bb92ea512eeb0653ccce116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e510e63ee38f6f6d9941f21855b350" id="r_af3e510e63ee38f6f6d9941f21855b350"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Func &gt; </td></tr>
<tr class="memitem:af3e510e63ee38f6f6d9941f21855b350"><td class="memTemplItemLeft" align="right" valign="top">Future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#af3e510e63ee38f6f6d9941f21855b350">DoForEach</a> (Iterator &amp;&amp;begin, Iterator &amp;&amp;end, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:af3e510e63ee38f6f6d9941f21855b350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute func for every iterator in the range [begin, end), in order.  <br /></td></tr>
<tr class="separator:af3e510e63ee38f6f6d9941f21855b350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0ed7ef8b61aea6c9442157ec6d70ea" id="r_adb0ed7ef8b61aea6c9442157ec6d70ea"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Func , typename  = std::invoke_result_t&lt;Func, typename Container::value_type&gt;&gt; </td></tr>
<tr class="memitem:adb0ed7ef8b61aea6c9442157ec6d70ea"><td class="memTemplItemLeft" align="right" valign="top">Future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#adb0ed7ef8b61aea6c9442157ec6d70ea">DoForEach</a> (Container &amp;container, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:adb0ed7ef8b61aea6c9442157ec6d70ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute func with each element in a container, in order.  <br /></td></tr>
<tr class="separator:adb0ed7ef8b61aea6c9442157ec6d70ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0c3b6c309ddeea5739d0ad15d5763a" id="r_aaf0c3b6c309ddeea5739d0ad15d5763a"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:aaf0c3b6c309ddeea5739d0ad15d5763a"><td class="memTemplItemLeft" align="right" valign="top">Future&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#aaf0c3b6c309ddeea5739d0ad15d5763a">DoFor</a> (std::size_t n, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:aaf0c3b6c309ddeea5739d0ad15d5763a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute func for several times.  <br /></td></tr>
<tr class="separator:aaf0c3b6c309ddeea5739d0ad15d5763a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be562910c25008d1388d7746bd7dc6b" id="r_a8be562910c25008d1388d7746bd7dc6b"><td class="memTemplParams" colspan="2">template&lt;typename... FutsType&gt; </td></tr>
<tr class="memitem:a8be562910c25008d1388d7746bd7dc6b"><td class="memTemplItemLeft" align="right" valign="top">Future&lt; std::tuple&lt; FutsType... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a8be562910c25008d1388d7746bd7dc6b">WhenAll</a> (FutsType &amp;&amp;... futs)</td></tr>
<tr class="memdesc:a8be562910c25008d1388d7746bd7dc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waiting for multiple futures at same time.  <br /></td></tr>
<tr class="separator:a8be562910c25008d1388d7746bd7dc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d247a94f5e0e1bf9b63bbaf06b5ed55" id="r_a9d247a94f5e0e1bf9b63bbaf06b5ed55"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename FutureType  = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt; </td></tr>
<tr class="memitem:a9d247a94f5e0e1bf9b63bbaf06b5ed55"><td class="memTemplItemLeft" align="right" valign="top">Future&lt; std::vector&lt; FutureType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a9d247a94f5e0e1bf9b63bbaf06b5ed55">WhenAll</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a9d247a94f5e0e1bf9b63bbaf06b5ed55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is as same as <a class="el" href="namespacetrpc.html#a8be562910c25008d1388d7746bd7dc6b">WhenAll(FutsType &amp;&amp;... futs)</a> , but accept two interators to set input futures.  <br /></td></tr>
<tr class="separator:a9d247a94f5e0e1bf9b63bbaf06b5ed55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac185b04e5d7f1e91f012e0862c5b8b2a" id="r_ac185b04e5d7f1e91f012e0862c5b8b2a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename FutureType  = typename std::iterator_traits&lt;InputIterator&gt;::value_type, typename FutureValueType  = typename FutureType::TupleValueType&gt; </td></tr>
<tr class="memitem:ac185b04e5d7f1e91f012e0862c5b8b2a"><td class="memTemplItemLeft" align="right" valign="top">Future&lt; size_t, FutureValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ac185b04e5d7f1e91f012e0862c5b8b2a">WhenAny</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:ac185b04e5d7f1e91f012e0862c5b8b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned future turns resulted, when any input future ready or failed.  <br /></td></tr>
<tr class="separator:ac185b04e5d7f1e91f012e0862c5b8b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ec567d6529704ca03bce928ecf72df" id="r_ad0ec567d6529704ca03bce928ecf72df"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename FutureType  = typename std::iterator_traits&lt;InputIterator&gt;::value_type, typename FutureValueType  = typename FutureType::TupleValueType&gt; </td></tr>
<tr class="memitem:ad0ec567d6529704ca03bce928ecf72df"><td class="memTemplItemLeft" align="right" valign="top">Future&lt; size_t, FutureValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ad0ec567d6529704ca03bce928ecf72df">WhenAnyWithoutException</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:ad0ec567d6529704ca03bce928ecf72df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned future turns resulted, when any input future ready or all input futures failed.  <br /></td></tr>
<tr class="separator:ad0ec567d6529704ca03bce928ecf72df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d405be04686b43e4da8192685d1261c" id="r_a0d405be04686b43e4da8192685d1261c"><td class="memTemplParams" colspan="2"><a id="a0d405be04686b43e4da8192685d1261c" name="a0d405be04686b43e4da8192685d1261c"></a>
template&lt;typename Func , typename... Args&gt; </td></tr>
<tr class="memitem:a0d405be04686b43e4da8192685d1261c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FuturizeInvoke</b> (Func &amp;&amp;func, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="separator:a0d405be04686b43e4da8192685d1261c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af713b2d105675f7dcbedf255faca66c3" id="r_af713b2d105675f7dcbedf255faca66c3"><td class="memTemplParams" colspan="2">template&lt;typename Lock , typename Func &gt; </td></tr>
<tr class="memitem:af713b2d105675f7dcbedf255faca66c3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#af713b2d105675f7dcbedf255faca66c3">WithLock</a> (Lock *lock, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:af713b2d105675f7dcbedf255faca66c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute func with lock, and unlock when it's done.  <br /></td></tr>
<tr class="separator:af713b2d105675f7dcbedf255faca66c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31d9f1a6c383812bde7ca3d61f7b2bb" id="r_ab31d9f1a6c383812bde7ca3d61f7b2bb"><td class="memItemLeft" align="right" valign="top"><a id="ab31d9f1a6c383812bde7ca3d61f7b2bb" name="ab31d9f1a6c383812bde7ca3d61f7b2bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>HeartBeat</b> (uint32_t task_queue_size)</td></tr>
<tr class="memdesc:ab31d9f1a6c383812bde7ca3d61f7b2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Framework use or for testing. It't Call by worker thread to report heartbeat information, thread-safe. <br /></td></tr>
<tr class="separator:ab31d9f1a6c383812bde7ca3d61f7b2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ff2f296184128304bee24654eec014" id="r_ae2ff2f296184128304bee24654eec014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ae2ff2f296184128304bee24654eec014">MakeServerContext</a> ()</td></tr>
<tr class="memdesc:ae2ff2f296184128304bee24654eec014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create server context.  <br /></td></tr>
<tr class="separator:ae2ff2f296184128304bee24654eec014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dbc4a3623df4deee1361f3bd4c8f67" id="r_ab6dbc4a3623df4deee1361f3bd4c8f67"><td class="memItemLeft" align="right" valign="top"><a id="ab6dbc4a3623df4deee1361f3bd4c8f67" name="ab6dbc4a3623df4deee1361f3bd4c8f67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetGlobalArenaOptions</b> (const google::protobuf::ArenaOptions &amp;options)</td></tr>
<tr class="memdesc:ab6dbc4a3623df4deee1361f3bd4c8f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ArenaOptions the user can set this function to realize the function of customizing Arena's Options if not set, use default option. <br /></td></tr>
<tr class="separator:ab6dbc4a3623df4deee1361f3bd4c8f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b49ff60cf45fbb6ec2e6d853a8b1bf7" id="r_a5b49ff60cf45fbb6ec2e6d853a8b1bf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a5b49ff60cf45fbb6ec2e6d853a8b1bf7">SetLocalServerContext</a> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;context)</td></tr>
<tr class="memdesc:a5b49ff60cf45fbb6ec2e6d853a8b1bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the context to a thread-private variable.  <br /></td></tr>
<tr class="separator:a5b49ff60cf45fbb6ec2e6d853a8b1bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e66df12b5ba86d583b735a21cc48b9" id="r_a95e66df12b5ba86d583b735a21cc48b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a95e66df12b5ba86d583b735a21cc48b9">GetLocalServerContext</a> ()</td></tr>
<tr class="memdesc:a95e66df12b5ba86d583b735a21cc48b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the context from a thread-private variable.  <br /></td></tr>
<tr class="separator:a95e66df12b5ba86d583b735a21cc48b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7be15d1f5d2499c00d486b7fbbfa03" id="r_aaf7be15d1f5d2499c00d486b7fbbfa03"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#aaf7be15d1f5d2499c00d486b7fbbfa03">GetHashValue</a> (std::uint64_t x)</td></tr>
<tr class="memdesc:aaf7be15d1f5d2499c00d486b7fbbfa03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hash value corresponding to the key value.  <br /></td></tr>
<tr class="separator:aaf7be15d1f5d2499c00d486b7fbbfa03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1c0ada829779b2b04aac03a6943a5a" id="r_a3f1c0ada829779b2b04aac03a6943a5a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a3f1c0ada829779b2b04aac03a6943a5a">GetHashIndex</a> (std::uint64_t x, std::uint64_t mod)</td></tr>
<tr class="memdesc:a3f1c0ada829779b2b04aac03a6943a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hash index.  <br /></td></tr>
<tr class="separator:a3f1c0ada829779b2b04aac03a6943a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a9748c76ef2b81fa39d133d2b5c275" id="r_ad2a9748c76ef2b81fa39d133d2b5c275"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ad2a9748c76ef2b81fa39d133d2b5c275">RoundUpPowerOf2</a> (std::size_t n)</td></tr>
<tr class="memdesc:ad2a9748c76ef2b81fa39d133d2b5c275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round up to the nearest power of 2.  <br /></td></tr>
<tr class="separator:ad2a9748c76ef2b81fa39d133d2b5c275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ec9ae2614be61186d05a815aca347a" id="r_af1ec9ae2614be61186d05a815aca347a"><td class="memTemplParams" colspan="2">template&lt;class T  = std::uint64_t, class  = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:af1ec9ae2614be61186d05a815aca347a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#af1ec9ae2614be61186d05a815aca347a">Random</a> ()</td></tr>
<tr class="memdesc:af1ec9ae2614be61186d05a815aca347a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random value of type <code>T</code>.  <br /></td></tr>
<tr class="separator:af1ec9ae2614be61186d05a815aca347a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed842dc7d05cf7707b6d0864a3082ef" id="r_aeed842dc7d05cf7707b6d0864a3082ef"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aeed842dc7d05cf7707b6d0864a3082ef"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#aeed842dc7d05cf7707b6d0864a3082ef">Random</a> (T min, T max)</td></tr>
<tr class="memdesc:aeed842dc7d05cf7707b6d0864a3082ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random value in range [min, max] (inclusive) of type <code>T</code>.  <br /></td></tr>
<tr class="separator:aeed842dc7d05cf7707b6d0864a3082ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f270e365d0543d969da063e32e12497" id="r_a4f270e365d0543d969da063e32e12497"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4f270e365d0543d969da063e32e12497"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a4f270e365d0543d969da063e32e12497">Random</a> (T max)</td></tr>
<tr class="memdesc:a4f270e365d0543d969da063e32e12497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <code>Random(0, max)</code>.  <br /></td></tr>
<tr class="separator:a4f270e365d0543d969da063e32e12497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019fd0fdc6aa511d454313e44622eed0" id="r_a019fd0fdc6aa511d454313e44622eed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="structtrpc_1_1memory__pool_1_1disabled_1_1detail_1_1_block.html">memory_pool::MemBlock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a019fd0fdc6aa511d454313e44622eed0">MakeBlockRef</a> (<a class="el" href="structtrpc_1_1memory__pool_1_1disabled_1_1detail_1_1_block.html">memory_pool::MemBlock</a> *ptr)</td></tr>
<tr class="memdesc:a019fd0fdc6aa511d454313e44622eed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap the MemBlock object in a Refer object for ease of use later.  <br /></td></tr>
<tr class="separator:a019fd0fdc6aa511d454313e44622eed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af913a7181ddb35698715bc5e482e896b" id="r_af913a7181ddb35698715bc5e482e896b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#af913a7181ddb35698715bc5e482e896b">GetBlockMaxAvailableSize</a> ()</td></tr>
<tr class="memdesc:af913a7181ddb35698715bc5e482e896b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the available data area size in the Block.  <br /></td></tr>
<tr class="separator:af913a7181ddb35698715bc5e482e896b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1301e2a724a6f90b0d2de3f01d725a5" id="r_ac1301e2a724a6f90b0d2de3f01d725a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1object__pool_1_1_lw_unique_ptr.html">object_pool::LwUniquePtr</a>&lt; <a class="el" href="structtrpc_1_1_buffer_block.html">BufferBlock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ac1301e2a724a6f90b0d2de3f01d725a5">CreateBufferBlockSlow</a> (std::string_view s)</td></tr>
<tr class="memdesc:ac1301e2a724a6f90b0d2de3f01d725a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the string to a <a class="el" href="structtrpc_1_1_buffer_block.html" title="Belongs to a middle layer object, mainly used by NoncontiguousBuffer.">BufferBlock</a> object.  <br /></td></tr>
<tr class="separator:ac1301e2a724a6f90b0d2de3f01d725a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d22c752d7333c1d96094a8ffb82220" id="r_a30d22c752d7333c1d96094a8ffb82220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1object__pool_1_1_lw_unique_ptr.html">object_pool::LwUniquePtr</a>&lt; <a class="el" href="structtrpc_1_1_buffer_block.html">BufferBlock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a30d22c752d7333c1d96094a8ffb82220">CreateBufferBlockSlow</a> (const void *ptr, std::size_t size)</td></tr>
<tr class="memdesc:a30d22c752d7333c1d96094a8ffb82220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of size <code>size</code> from <code>ptr</code> to a <a class="el" href="structtrpc_1_1_buffer_block.html" title="Belongs to a middle layer object, mainly used by NoncontiguousBuffer.">BufferBlock</a> object.  <br /></td></tr>
<tr class="separator:a30d22c752d7333c1d96094a8ffb82220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae311409b795db0390d414b0df18e0305" id="r_ae311409b795db0390d414b0df18e0305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ae311409b795db0390d414b0df18e0305">CreateBufferSlow</a> (std::string_view s)</td></tr>
<tr class="memdesc:ae311409b795db0390d414b0df18e0305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the string to a <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> object.  <br /></td></tr>
<tr class="separator:ae311409b795db0390d414b0df18e0305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f0e1918294921dd71a8a5919d2335f" id="r_a89f0e1918294921dd71a8a5919d2335f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a89f0e1918294921dd71a8a5919d2335f">CreateBufferSlow</a> (const void *ptr, std::size_t size)</td></tr>
<tr class="memdesc:a89f0e1918294921dd71a8a5919d2335f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of <code>ptr</code> of size <code>size</code> to the <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> object.  <br /></td></tr>
<tr class="separator:a89f0e1918294921dd71a8a5919d2335f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd048d40ab0ba907b3e102f0bf42da8" id="r_a1dd048d40ab0ba907b3e102f0bf42da8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a1dd048d40ab0ba907b3e102f0bf42da8">FlattenSlow</a> (const <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &amp;nb, std::size_t max_bytes=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="memdesc:a1dd048d40ab0ba907b3e102f0bf42da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> to a string object.  <br /></td></tr>
<tr class="separator:a1dd048d40ab0ba907b3e102f0bf42da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdd8bda3736550d82d09ce6c902b705" id="r_a6cdd8bda3736550d82d09ce6c902b705"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a6cdd8bda3736550d82d09ce6c902b705">FlattenSlowUntil</a> (const <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &amp;nb, std::string_view delim, std::size_t max_bytes=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="memdesc:a6cdd8bda3736550d82d09ce6c902b705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the content of delim in nb.  <br /></td></tr>
<tr class="separator:a6cdd8bda3736550d82d09ce6c902b705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac691d2921e835345806cbd71e66ed8d8" id="r_ac691d2921e835345806cbd71e66ed8d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ac691d2921e835345806cbd71e66ed8d8">FlattenToSlow</a> (const <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &amp;nb, void *buffer, std::size_t size)</td></tr>
<tr class="memdesc:ac691d2921e835345806cbd71e66ed8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy size bytes from <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> to contiguous buffer.  <br /></td></tr>
<tr class="separator:ac691d2921e835345806cbd71e66ed8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4e67c948c69b506f29adb1ec802bee" id="r_a4e4e67c948c69b506f29adb1ec802bee"><td class="memItemLeft" align="right" valign="top"><a id="a4e4e67c948c69b506f29adb1ec802bee" name="a4e4e67c948c69b506f29adb1ec802bee"></a>
std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>ReadSteadyClock</b> ()</td></tr>
<tr class="memdesc:a4e4e67c948c69b506f29adb1ec802bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>std::chrono::steady_clock::now()</code>, except that this one can be faster if <code>std</code>'s counterpart is implemented in terms of <code>syscall</code> (this is the case for libstdc++ <code>configure</code>d on CentOS6 with default options). <br /></td></tr>
<tr class="separator:a4e4e67c948c69b506f29adb1ec802bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d77c84a58f3736615c6c8f3197e356d" id="r_a4d77c84a58f3736615c6c8f3197e356d"><td class="memItemLeft" align="right" valign="top">std::chrono::system_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a4d77c84a58f3736615c6c8f3197e356d">ReadSystemClock</a> ()</td></tr>
<tr class="memdesc:a4d77c84a58f3736615c6c8f3197e356d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>std::chrono::system_clock::now()</code>.  <br /></td></tr>
<tr class="separator:a4d77c84a58f3736615c6c8f3197e356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c96af6d310610e307458bdf8fb4ad8d" id="r_a7c96af6d310610e307458bdf8fb4ad8d"><td class="memItemLeft" align="right" valign="top">std::chrono::nanoseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a7c96af6d310610e307458bdf8fb4ad8d">DurationFromTsc</a> (std::uint64_t start, std::uint64_t to)</td></tr>
<tr class="memdesc:a7c96af6d310610e307458bdf8fb4ad8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">read value of Tsc and return to caller  <br /></td></tr>
<tr class="separator:a7c96af6d310610e307458bdf8fb4ad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cef90e38352d092c92ee3a21c1ba50" id="r_a52cef90e38352d092c92ee3a21c1ba50"><td class="memItemLeft" align="right" valign="top"><a id="a52cef90e38352d092c92ee3a21c1ba50" name="a52cef90e38352d092c92ee3a21c1ba50"></a>
std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>TimestampFromTsc</b> (std::uint64_t tsc)</td></tr>
<tr class="separator:a52cef90e38352d092c92ee3a21c1ba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edf0e8e3451c89e0710d91d79a39019" id="r_a0edf0e8e3451c89e0710d91d79a39019"><td class="memItemLeft" align="right" valign="top"><a id="a0edf0e8e3451c89e0710d91d79a39019" name="a0edf0e8e3451c89e0710d91d79a39019"></a>
<a class="el" href="classtrpc_1_1_hazptr_domain.html">HazptrDomain</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetDefaultHazptrDomain</b> ()</td></tr>
<tr class="separator:a0edf0e8e3451c89e0710d91d79a39019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8de66e062aac2ce1202dea876833336" id="r_af8de66e062aac2ce1202dea876833336"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:af8de66e062aac2ce1202dea876833336"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#af8de66e062aac2ce1202dea876833336">TryParse</a> (const std::string_view &amp;s, const Args &amp;... args)</td></tr>
<tr class="memdesc:af8de66e062aac2ce1202dea876833336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try parse <code>s</code> as <code>T</code>.  <br /></td></tr>
<tr class="separator:af8de66e062aac2ce1202dea876833336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65fd68ee212a7a59a269c9f9f0dc7cf" id="r_ab65fd68ee212a7a59a269c9f9f0dc7cf"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab65fd68ee212a7a59a269c9f9f0dc7cf"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ab65fd68ee212a7a59a269c9f9f0dc7cf">Format</a> (const std::string_view &amp;fmt, const Args &amp;... args)</td></tr>
<tr class="separator:ab65fd68ee212a7a59a269c9f9f0dc7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2053e9f50e903ee6e0f52699f7a0728" id="r_ab2053e9f50e903ee6e0f52699f7a0728"><td class="memItemLeft" align="right" valign="top"><a id="ab2053e9f50e903ee6e0f52699f7a0728" name="ab2053e9f50e903ee6e0f52699f7a0728"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>StartsWith</b> (const std::string_view &amp;s, const std::string_view &amp;prefix)</td></tr>
<tr class="memdesc:ab2053e9f50e903ee6e0f52699f7a0728"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>std::string(_view)::starts_with/ends_with</code> is not available until C++20, so we roll our own here. <br /></td></tr>
<tr class="separator:ab2053e9f50e903ee6e0f52699f7a0728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4cda2004d5923b6b9fdd6cedfa6ecf" id="r_adb4cda2004d5923b6b9fdd6cedfa6ecf"><td class="memItemLeft" align="right" valign="top"><a id="adb4cda2004d5923b6b9fdd6cedfa6ecf" name="adb4cda2004d5923b6b9fdd6cedfa6ecf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>EndsWith</b> (const std::string_view &amp;s, const std::string_view &amp;suffix)</td></tr>
<tr class="separator:adb4cda2004d5923b6b9fdd6cedfa6ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1436730d888df17efcf37e9a5b2b38" id="r_aaa1436730d888df17efcf37e9a5b2b38"><td class="memItemLeft" align="right" valign="top"><a id="aaa1436730d888df17efcf37e9a5b2b38" name="aaa1436730d888df17efcf37e9a5b2b38"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (const std::string_view &amp;from, const std::string_view &amp;to, std::string *str, std::size_t count=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="memdesc:aaa1436730d888df17efcf37e9a5b2b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace occurrance of <code>from</code> in <code>str</code> to <code>to</code> for at most <code>count</code> times. <br /></td></tr>
<tr class="separator:aaa1436730d888df17efcf37e9a5b2b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30717ed47bd1a8a68accbbef43781d1" id="r_ab30717ed47bd1a8a68accbbef43781d1"><td class="memItemLeft" align="right" valign="top"><a id="ab30717ed47bd1a8a68accbbef43781d1" name="ab30717ed47bd1a8a68accbbef43781d1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (const std::string_view &amp;str, const std::string_view &amp;from, const std::string_view &amp;to, std::size_t count=std::numeric_limits&lt; std::size_t &gt;::max())</td></tr>
<tr class="separator:ab30717ed47bd1a8a68accbbef43781d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd1c4a3deb9b1e7943bf528e12cc65a" id="r_adcd1c4a3deb9b1e7943bf528e12cc65a"><td class="memItemLeft" align="right" valign="top"><a id="adcd1c4a3deb9b1e7943bf528e12cc65a" name="adcd1c4a3deb9b1e7943bf528e12cc65a"></a>
std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>Trim</b> (const std::string_view &amp;str)</td></tr>
<tr class="memdesc:adcd1c4a3deb9b1e7943bf528e12cc65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace at both end of the string. <br /></td></tr>
<tr class="separator:adcd1c4a3deb9b1e7943bf528e12cc65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9afac42e4f66070477abfa414812b2" id="r_a1f9afac42e4f66070477abfa414812b2"><td class="memItemLeft" align="right" valign="top"><a id="a1f9afac42e4f66070477abfa414812b2" name="a1f9afac42e4f66070477abfa414812b2"></a>
std::vector&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Split</b> (const std::string_view &amp;s, char delim, bool keep_empty=false)</td></tr>
<tr class="memdesc:a1f9afac42e4f66070477abfa414812b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split string by <code>delim</code>. <br /></td></tr>
<tr class="separator:a1f9afac42e4f66070477abfa414812b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6158c1807b1b07822bc4b2ba0c4b68d7" id="r_a6158c1807b1b07822bc4b2ba0c4b68d7"><td class="memItemLeft" align="right" valign="top"><a id="a6158c1807b1b07822bc4b2ba0c4b68d7" name="a6158c1807b1b07822bc4b2ba0c4b68d7"></a>
std::vector&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Split</b> (const std::string_view &amp;s, const std::string_view &amp;delim, bool keep_empty=false)</td></tr>
<tr class="separator:a6158c1807b1b07822bc4b2ba0c4b68d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890a1d7d5be159fa341a12a7203bbf4d" id="r_a890a1d7d5be159fa341a12a7203bbf4d"><td class="memItemLeft" align="right" valign="top"><a id="a890a1d7d5be159fa341a12a7203bbf4d" name="a890a1d7d5be159fa341a12a7203bbf4d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Join</b> (const std::vector&lt; std::string_view &gt; &amp;parts, const std::string_view &amp;delim)</td></tr>
<tr class="memdesc:a890a1d7d5be159fa341a12a7203bbf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join strings in <code>parts</code>, delimited by <code>delim</code>. <br /></td></tr>
<tr class="separator:a890a1d7d5be159fa341a12a7203bbf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af587f081b6a97f16e01960d199225068" id="r_af587f081b6a97f16e01960d199225068"><td class="memItemLeft" align="right" valign="top"><a id="af587f081b6a97f16e01960d199225068" name="af587f081b6a97f16e01960d199225068"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>Join</b> (const std::vector&lt; std::string &gt; &amp;parts, const std::string_view &amp;delim)</td></tr>
<tr class="separator:af587f081b6a97f16e01960d199225068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4094aad730d15dc22cccf870507c9b02" id="r_a4094aad730d15dc22cccf870507c9b02"><td class="memItemLeft" align="right" valign="top"><a id="a4094aad730d15dc22cccf870507c9b02" name="a4094aad730d15dc22cccf870507c9b02"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>ToUpper</b> (char c)</td></tr>
<tr class="memdesc:a4094aad730d15dc22cccf870507c9b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">To uppercase / lowercase. <br /></td></tr>
<tr class="separator:a4094aad730d15dc22cccf870507c9b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e419cbad96cb5b94e2b66a1b6c7bc4a" id="r_a4e419cbad96cb5b94e2b66a1b6c7bc4a"><td class="memItemLeft" align="right" valign="top"><a id="a4e419cbad96cb5b94e2b66a1b6c7bc4a" name="a4e419cbad96cb5b94e2b66a1b6c7bc4a"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>ToLower</b> (char c)</td></tr>
<tr class="separator:a4e419cbad96cb5b94e2b66a1b6c7bc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced7a0e6ae4e222109452fb4da908135" id="r_aced7a0e6ae4e222109452fb4da908135"><td class="memItemLeft" align="right" valign="top"><a id="aced7a0e6ae4e222109452fb4da908135" name="aced7a0e6ae4e222109452fb4da908135"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ToUpper</b> (std::string *s)</td></tr>
<tr class="separator:aced7a0e6ae4e222109452fb4da908135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457296a893f5e22f20a82911f24fb580" id="r_a457296a893f5e22f20a82911f24fb580"><td class="memItemLeft" align="right" valign="top"><a id="a457296a893f5e22f20a82911f24fb580" name="a457296a893f5e22f20a82911f24fb580"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ToLower</b> (std::string *s)</td></tr>
<tr class="separator:a457296a893f5e22f20a82911f24fb580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96d8eb9629da8f5acffe9bdc678ecc4" id="r_ae96d8eb9629da8f5acffe9bdc678ecc4"><td class="memItemLeft" align="right" valign="top"><a id="ae96d8eb9629da8f5acffe9bdc678ecc4" name="ae96d8eb9629da8f5acffe9bdc678ecc4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>ToUpper</b> (const std::string_view &amp;s)</td></tr>
<tr class="separator:ae96d8eb9629da8f5acffe9bdc678ecc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc3ffa52c84b5a5603cb2b82619ab5" id="r_af2bc3ffa52c84b5a5603cb2b82619ab5"><td class="memItemLeft" align="right" valign="top"><a id="af2bc3ffa52c84b5a5603cb2b82619ab5" name="af2bc3ffa52c84b5a5603cb2b82619ab5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>ToLower</b> (const std::string_view &amp;s)</td></tr>
<tr class="separator:af2bc3ffa52c84b5a5603cb2b82619ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9eaf2c5c83876abc0ef5efb12f6061" id="r_a3f9eaf2c5c83876abc0ef5efb12f6061"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a3f9eaf2c5c83876abc0ef5efb12f6061">IEquals</a> (const std::string_view &amp;first, const std::string_view &amp;second)</td></tr>
<tr class="memdesc:a3f9eaf2c5c83876abc0ef5efb12f6061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case insensitive-comparison.  <br /></td></tr>
<tr class="separator:a3f9eaf2c5c83876abc0ef5efb12f6061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29052f2a896b59a8c75181f6012df7f8" id="r_a29052f2a896b59a8c75181f6012df7f8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a29052f2a896b59a8c75181f6012df7f8">GetCurrentProcessorId</a> ()</td></tr>
<tr class="memdesc:a29052f2a896b59a8c75181f6012df7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current CPU ID.  <br /></td></tr>
<tr class="separator:a29052f2a896b59a8c75181f6012df7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b768e7b06fd3368bb20b7e431b89c49" id="r_a2b768e7b06fd3368bb20b7e431b89c49"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a2b768e7b06fd3368bb20b7e431b89c49">GetNumberOfProcessorsAvailable</a> ()</td></tr>
<tr class="memdesc:a2b768e7b06fd3368bb20b7e431b89c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of available CPUs for the program.  <br /></td></tr>
<tr class="separator:a2b768e7b06fd3368bb20b7e431b89c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2f3a4fcd957b0e83a8f3909eb310dd" id="r_acc2f3a4fcd957b0e83a8f3909eb310dd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#acc2f3a4fcd957b0e83a8f3909eb310dd">GetNumberOfProcessorsConfigured</a> ()</td></tr>
<tr class="memdesc:acc2f3a4fcd957b0e83a8f3909eb310dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of CPUs on the host machine.  <br /></td></tr>
<tr class="separator:acc2f3a4fcd957b0e83a8f3909eb310dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47eb787840b413c95871db49333a5b99" id="r_a47eb787840b413c95871db49333a5b99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a47eb787840b413c95871db49333a5b99">IsInaccessibleProcessorPresent</a> ()</td></tr>
<tr class="memdesc:a47eb787840b413c95871db49333a5b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are any unavailable CPUs.  <br /></td></tr>
<tr class="separator:a47eb787840b413c95871db49333a5b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3f804b928683a742509c0ccdd8abce" id="r_abd3f804b928683a742509c0ccdd8abce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#abd3f804b928683a742509c0ccdd8abce">IsProcessorAccessible</a> (unsigned cpu)</td></tr>
<tr class="memdesc:abd3f804b928683a742509c0ccdd8abce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a specified CPU is available.  <br /></td></tr>
<tr class="separator:abd3f804b928683a742509c0ccdd8abce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf2ad03c3081eb53b0d7f237dc3f90d" id="r_aecf2ad03c3081eb53b0d7f237dc3f90d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; unsigned &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#aecf2ad03c3081eb53b0d7f237dc3f90d">TryParseProcesserList</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:aecf2ad03c3081eb53b0d7f237dc3f90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the CPU group configuration.  <br /></td></tr>
<tr class="separator:aecf2ad03c3081eb53b0d7f237dc3f90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e241da15e5cbaffb768b6eb35c606e" id="r_a83e241da15e5cbaffb768b6eb35c606e"><td class="memItemLeft" align="right" valign="top"><a id="a83e241da15e5cbaffb768b6eb35c606e" name="a83e241da15e5cbaffb768b6eb35c606e"></a>
<a class="el" href="structtrpc_1_1_per_thread_worker.html">PerThreadWorker</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ThisWorker</b> ()</td></tr>
<tr class="separator:a83e241da15e5cbaffb768b6eb35c606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4beeb72cc88fade2eac84b7d052be0" id="r_a4e4beeb72cc88fade2eac84b7d052be0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a4e4beeb72cc88fade2eac84b7d052be0">IsProcessInContainer</a> ()</td></tr>
<tr class="memdesc:a4e4beeb72cc88fade2eac84b7d052be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the process is running in a container environment.  <br /></td></tr>
<tr class="separator:a4e4beeb72cc88fade2eac84b7d052be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2620fa099e6064e6aa05b683d8066ff5" id="r_a2620fa099e6064e6aa05b683d8066ff5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a2620fa099e6064e6aa05b683d8066ff5">GetProcessCpuQuota</a> (const std::function&lt; bool()&gt; &amp;check_container=<a class="el" href="namespacetrpc.html#a4e4beeb72cc88fade2eac84b7d052be0">IsProcessInContainer</a>)</td></tr>
<tr class="memdesc:a2620fa099e6064e6aa05b683d8066ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the available CPU quota (number of cores) for the process.  <br /></td></tr>
<tr class="separator:a2620fa099e6064e6aa05b683d8066ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dce2f0ca94ccf9611c30d3aeb6f042" id="r_ab3dce2f0ca94ccf9611c30d3aeb6f042"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ab3dce2f0ca94ccf9611c30d3aeb6f042">GetProcessMemoryQuota</a> (const std::function&lt; bool()&gt; &amp;check_container=<a class="el" href="namespacetrpc.html#a4e4beeb72cc88fade2eac84b7d052be0">IsProcessInContainer</a>)</td></tr>
<tr class="memdesc:ab3dce2f0ca94ccf9611c30d3aeb6f042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the available memory quota (in bytes) for a process.  <br /></td></tr>
<tr class="separator:ab3dce2f0ca94ccf9611c30d3aeb6f042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6f624a09d7825ec2938bb5a5ab1a6" id="r_a4bd6f624a09d7825ec2938bb5a5ab1a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a4bd6f624a09d7825ec2938bb5a5ab1a6">TrySetCurrentThreadAffinity</a> (const std::vector&lt; unsigned &gt; &amp;affinity)</td></tr>
<tr class="memdesc:a4bd6f624a09d7825ec2938bb5a5ab1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to set the CPU affinity of the current thread.  <br /></td></tr>
<tr class="separator:a4bd6f624a09d7825ec2938bb5a5ab1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824a2a1044132328f4cf60c3a1b678c7" id="r_a824a2a1044132328f4cf60c3a1b678c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a824a2a1044132328f4cf60c3a1b678c7">SetCurrentThreadAffinity</a> (const std::vector&lt; unsigned &gt; &amp;affinity)</td></tr>
<tr class="memdesc:a824a2a1044132328f4cf60c3a1b678c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CPU affinity of the current thread.  <br /></td></tr>
<tr class="separator:a824a2a1044132328f4cf60c3a1b678c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b859883f0229a9b1446f4c7ba29bcd2" id="r_a0b859883f0229a9b1446f4c7ba29bcd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a0b859883f0229a9b1446f4c7ba29bcd2">TryGetCurrentThreadAffinity</a> (std::vector&lt; unsigned &gt; &amp;affinity)</td></tr>
<tr class="memdesc:a0b859883f0229a9b1446f4c7ba29bcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the CPU affinity of the current thread.  <br /></td></tr>
<tr class="separator:a0b859883f0229a9b1446f4c7ba29bcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65a4c7b98748e547c4c069b19d594a8" id="r_af65a4c7b98748e547c4c069b19d594a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#af65a4c7b98748e547c4c069b19d594a8">GetCurrentThreadAffinity</a> ()</td></tr>
<tr class="memdesc:af65a4c7b98748e547c4c069b19d594a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CPU affinity of the current thread.  <br /></td></tr>
<tr class="separator:af65a4c7b98748e547c4c069b19d594a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fc8982d45386c1a9f7bce8ea904260" id="r_af0fc8982d45386c1a9f7bce8ea904260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#af0fc8982d45386c1a9f7bce8ea904260">SetCurrentThreadName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:af0fc8982d45386c1a9f7bce8ea904260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current thread name displayed in the top command.  <br /></td></tr>
<tr class="separator:af0fc8982d45386c1a9f7bce8ea904260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc29ec07c2130fb2e3339be8a38f169c" id="r_abc29ec07c2130fb2e3339be8a38f169c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#abc29ec07c2130fb2e3339be8a38f169c">ParseBindCoreConfig</a> (const std::string &amp;bind_core_conf, std::vector&lt; uint32_t &gt; &amp;bind_core_group)</td></tr>
<tr class="memdesc:abc29ec07c2130fb2e3339be8a38f169c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the core binding configuration and check its validity.  <br /></td></tr>
<tr class="separator:abc29ec07c2130fb2e3339be8a38f169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffb87a4c00243ebf7408e4abba4dfd2" id="r_aeffb87a4c00243ebf7408e4abba4dfd2"><td class="memTemplParams" colspan="2"><a id="aeffb87a4c00243ebf7408e4abba4dfd2" name="aeffb87a4c00243ebf7408e4abba4dfd2"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:aeffb87a4c00243ebf7408e4abba4dfd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_erased_ptr.html">ErasedPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeErased</b> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aeffb87a4c00243ebf7408e4abba4dfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <code><a class="el" href="classtrpc_1_1_erased_ptr.html" title="RAII wrapper for holding type erased pointers.">ErasedPtr</a></code> <br /></td></tr>
<tr class="separator:aeffb87a4c00243ebf7408e4abba4dfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f69ad6a9fe5200e8a92b0a9afef599e" id="r_a4f69ad6a9fe5200e8a92b0a9afef599e"><td class="memTemplParams" colspan="2"><a id="a4f69ad6a9fe5200e8a92b0a9afef599e" name="a4f69ad6a9fe5200e8a92b0a9afef599e"></a>
template&lt;class R , class... Args&gt; </td></tr>
<tr class="memitem:a4f69ad6a9fe5200e8a92b0a9afef599e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Function</b> (R(*)(Args...)) -&gt; <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; R(Args...)&gt;</td></tr>
<tr class="separator:a4f69ad6a9fe5200e8a92b0a9afef599e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e90ae57cccf8e45a8f0a292bfb2720" id="r_af1e90ae57cccf8e45a8f0a292bfb2720"><td class="memTemplParams" colspan="2"><a id="af1e90ae57cccf8e45a8f0a292bfb2720" name="af1e90ae57cccf8e45a8f0a292bfb2720"></a>
template&lt;class F , class Signature  = details::FunctionSignature&lt;decltype(&amp;F::operator())&gt;&gt; </td></tr>
<tr class="memitem:af1e90ae57cccf8e45a8f0a292bfb2720"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Function</b> (F) -&gt; <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; Signature &gt;</td></tr>
<tr class="separator:af1e90ae57cccf8e45a8f0a292bfb2720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6b1a832a167d60d1da5e56f7be01e0" id="r_a6d6b1a832a167d60d1da5e56f7be01e0"><td class="memTemplParams" colspan="2"><a id="a6d6b1a832a167d60d1da5e56f7be01e0" name="a6d6b1a832a167d60d1da5e56f7be01e0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6d6b1a832a167d60d1da5e56f7be01e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; T &gt; &amp;f, std::nullptr_t)</td></tr>
<tr class="separator:a6d6b1a832a167d60d1da5e56f7be01e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ba0fcc41e7dad115f7fd6dd948cc5a" id="r_a57ba0fcc41e7dad115f7fd6dd948cc5a"><td class="memTemplParams" colspan="2"><a id="a57ba0fcc41e7dad115f7fd6dd948cc5a" name="a57ba0fcc41e7dad115f7fd6dd948cc5a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a57ba0fcc41e7dad115f7fd6dd948cc5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t, const <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="separator:a57ba0fcc41e7dad115f7fd6dd948cc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abb49a89f95f2ed6033cbcbd319476b" id="r_a6abb49a89f95f2ed6033cbcbd319476b"><td class="memTemplParams" colspan="2"><a id="a6abb49a89f95f2ed6033cbcbd319476b" name="a6abb49a89f95f2ed6033cbcbd319476b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6abb49a89f95f2ed6033cbcbd319476b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; T &gt; &amp;f, std::nullptr_t)</td></tr>
<tr class="separator:a6abb49a89f95f2ed6033cbcbd319476b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c82ec02dd393e05fc04f6cdb1cfab35" id="r_a0c82ec02dd393e05fc04f6cdb1cfab35"><td class="memTemplParams" colspan="2"><a id="a0c82ec02dd393e05fc04f6cdb1cfab35" name="a0c82ec02dd393e05fc04f6cdb1cfab35"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0c82ec02dd393e05fc04f6cdb1cfab35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (std::nullptr_t, const <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="separator:a0c82ec02dd393e05fc04f6cdb1cfab35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedae3cd03401d7a4c4485e9c570d67d8" id="r_aedae3cd03401d7a4c4485e9c570d67d8"><td class="memTemplParams" colspan="2"><a id="aedae3cd03401d7a4c4485e9c570d67d8" name="aedae3cd03401d7a4c4485e9c570d67d8"></a>
template&lt;class T , class... Us&gt; </td></tr>
<tr class="memitem:aedae3cd03401d7a4c4485e9c570d67d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeRefCounted</b> (Us &amp;&amp;... args)</td></tr>
<tr class="separator:aedae3cd03401d7a4c4485e9c570d67d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948c28d96886c41a4e88172778ddd599" id="r_a948c28d96886c41a4e88172778ddd599"><td class="memTemplParams" colspan="2"><a id="a948c28d96886c41a4e88172778ddd599" name="a948c28d96886c41a4e88172778ddd599"></a>
template&lt;typename _Tp , typename _Up &gt; </td></tr>
<tr class="memitem:a948c28d96886c41a4e88172778ddd599"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_pointer_cast</b> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; _Up &gt; &amp;__r) noexcept</td></tr>
<tr class="separator:a948c28d96886c41a4e88172778ddd599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a167791112bbd7727798a094a032065" id="r_a1a167791112bbd7727798a094a032065"><td class="memTemplParams" colspan="2"><a id="a1a167791112bbd7727798a094a032065" name="a1a167791112bbd7727798a094a032065"></a>
template&lt;typename _Tp , typename _Up &gt; </td></tr>
<tr class="memitem:a1a167791112bbd7727798a094a032065"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>const_pointer_cast</b> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; _Up &gt; &amp;__r) noexcept</td></tr>
<tr class="separator:a1a167791112bbd7727798a094a032065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0e1bd36e9d1b82fc44a044d4964ae7" id="r_aad0e1bd36e9d1b82fc44a044d4964ae7"><td class="memTemplParams" colspan="2"><a id="aad0e1bd36e9d1b82fc44a044d4964ae7" name="aad0e1bd36e9d1b82fc44a044d4964ae7"></a>
template&lt;typename _Tp , typename _Up &gt; </td></tr>
<tr class="memitem:aad0e1bd36e9d1b82fc44a044d4964ae7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_pointer_cast</b> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; _Up &gt; &amp;__r) noexcept</td></tr>
<tr class="separator:aad0e1bd36e9d1b82fc44a044d4964ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c64b699bb1bcda0aec1e3e494c3b7f" id="r_ab6c64b699bb1bcda0aec1e3e494c3b7f"><td class="memItemLeft" align="right" valign="top"><a id="ab6c64b699bb1bcda0aec1e3e494c3b7f" name="ab6c64b699bb1bcda0aec1e3e494c3b7f"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetSystemNanoSeconds</b> ()</td></tr>
<tr class="memdesc:ab6c64b699bb1bcda0aec1e3e494c3b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nanoseconds from the Epoch to now. <br /></td></tr>
<tr class="separator:ab6c64b699bb1bcda0aec1e3e494c3b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2598b7b2c40c9cb6153e83f309e2c342" id="r_a2598b7b2c40c9cb6153e83f309e2c342"><td class="memItemLeft" align="right" valign="top"><a id="a2598b7b2c40c9cb6153e83f309e2c342" name="a2598b7b2c40c9cb6153e83f309e2c342"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetSystemMicroSeconds</b> ()</td></tr>
<tr class="memdesc:a2598b7b2c40c9cb6153e83f309e2c342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of microseconds from the Epoch to now. <br /></td></tr>
<tr class="separator:a2598b7b2c40c9cb6153e83f309e2c342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15798720d74201f4663917f21dc43dd7" id="r_a15798720d74201f4663917f21dc43dd7"><td class="memItemLeft" align="right" valign="top"><a id="a15798720d74201f4663917f21dc43dd7" name="a15798720d74201f4663917f21dc43dd7"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetSystemMilliSeconds</b> ()</td></tr>
<tr class="memdesc:a15798720d74201f4663917f21dc43dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of milliseconds from the Epoch to now. <br /></td></tr>
<tr class="separator:a15798720d74201f4663917f21dc43dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b49f025c0d5f46987a23f7ed2a03cec" id="r_a6b49f025c0d5f46987a23f7ed2a03cec"><td class="memItemLeft" align="right" valign="top"><a id="a6b49f025c0d5f46987a23f7ed2a03cec" name="a6b49f025c0d5f46987a23f7ed2a03cec"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetSteadyNanoSeconds</b> ()</td></tr>
<tr class="memdesc:a6b49f025c0d5f46987a23f7ed2a03cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nanoseconds from system boot to now. <br /></td></tr>
<tr class="separator:a6b49f025c0d5f46987a23f7ed2a03cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0db9ad0c209ea3d140d249bec3e3a29" id="r_ad0db9ad0c209ea3d140d249bec3e3a29"><td class="memItemLeft" align="right" valign="top"><a id="ad0db9ad0c209ea3d140d249bec3e3a29" name="ad0db9ad0c209ea3d140d249bec3e3a29"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetSteadyMicroSeconds</b> ()</td></tr>
<tr class="memdesc:ad0db9ad0c209ea3d140d249bec3e3a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of microseconds from system boot to now. <br /></td></tr>
<tr class="separator:ad0db9ad0c209ea3d140d249bec3e3a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564671f876e5de1fc92bcae1196ed27f" id="r_a564671f876e5de1fc92bcae1196ed27f"><td class="memItemLeft" align="right" valign="top"><a id="a564671f876e5de1fc92bcae1196ed27f" name="a564671f876e5de1fc92bcae1196ed27f"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetSteadyMilliSeconds</b> ()</td></tr>
<tr class="memdesc:a564671f876e5de1fc92bcae1196ed27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of milliseconds from system boot to now. <br /></td></tr>
<tr class="separator:a564671f876e5de1fc92bcae1196ed27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8d342e0325cf8c594b974d26a4ab6f" id="r_afb8d342e0325cf8c594b974d26a4ab6f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#afb8d342e0325cf8c594b974d26a4ab6f">GetNanoSeconds</a> ()</td></tr>
<tr class="memdesc:afb8d342e0325cf8c594b974d26a4ab6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timestamp in nanoseconds.  <br /></td></tr>
<tr class="separator:afb8d342e0325cf8c594b974d26a4ab6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ba2ab44a061e0ca72d1440f43be691" id="r_ae9ba2ab44a061e0ca72d1440f43be691"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ae9ba2ab44a061e0ca72d1440f43be691">GetMicroSeconds</a> ()</td></tr>
<tr class="memdesc:ae9ba2ab44a061e0ca72d1440f43be691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timestamp in microseconds.  <br /></td></tr>
<tr class="separator:ae9ba2ab44a061e0ca72d1440f43be691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fb228a6922c63a5d42628e0396c7e6" id="r_a13fb228a6922c63a5d42628e0396c7e6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a13fb228a6922c63a5d42628e0396c7e6">GetMilliSeconds</a> ()</td></tr>
<tr class="memdesc:a13fb228a6922c63a5d42628e0396c7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timestamp in millseconds.  <br /></td></tr>
<tr class="separator:a13fb228a6922c63a5d42628e0396c7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ec276e69b45e1ef8d4c4f06ffbc18e" id="r_ad9ec276e69b45e1ef8d4c4f06ffbc18e"><td class="memItemLeft" align="right" valign="top"><a id="ad9ec276e69b45e1ef8d4c4f06ffbc18e" name="ad9ec276e69b45e1ef8d4c4f06ffbc18e"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetNowAsTimeT</b> ()</td></tr>
<tr class="memdesc:ad9ec276e69b45e1ef8d4c4f06ffbc18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of seconds from the Epoch to now in time_t struct. <br /></td></tr>
<tr class="separator:ad9ec276e69b45e1ef8d4c4f06ffbc18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa048a3e05b9707b71199f2837c311b63" id="r_aa048a3e05b9707b71199f2837c311b63"><td class="memItemLeft" align="right" valign="top"><a id="aa048a3e05b9707b71199f2837c311b63" name="aa048a3e05b9707b71199f2837c311b63"></a>
timeval&#160;</td><td class="memItemRight" valign="bottom"><b>GetNowAsTimeVal</b> ()</td></tr>
<tr class="memdesc:aa048a3e05b9707b71199f2837c311b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the milliseconds from epoch in timeval struct. <br /></td></tr>
<tr class="separator:aa048a3e05b9707b71199f2837c311b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a91613ea874e15a4a4f7ba811d5f633b7" id="r_a91613ea874e15a4a4f7ba811d5f633b7"><td class="memItemLeft" align="right" valign="top"><a id="a91613ea874e15a4a4f7ba811d5f633b7" name="a91613ea874e15a4a4f7ba811d5f633b7"></a>
constexpr char *const&#160;</td><td class="memItemRight" valign="bottom"><b>kNonRpcName</b> = const_cast&lt;char*&gt;(&quot;_non_rpc_&quot;)</td></tr>
<tr class="memdesc:a91613ea874e15a4a4f7ba811d5f633b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default function name of Non-RPC. <br /></td></tr>
<tr class="separator:a91613ea874e15a4a4f7ba811d5f633b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209d15915115be886e31a86e8f32e172" id="r_a209d15915115be886e31a86e8f32e172"><td class="memItemLeft" align="right" valign="top"><a id="a209d15915115be886e31a86e8f32e172" name="a209d15915115be886e31a86e8f32e172"></a>
constexpr char *const&#160;</td><td class="memItemRight" valign="bottom"><b>kTransparentRpcName</b> = const_cast&lt;char*&gt;(&quot;_transparent_rpc_&quot;)</td></tr>
<tr class="memdesc:a209d15915115be886e31a86e8f32e172"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default the function name of transparent forwarding RPC where the server just sends it to upstream. <br /></td></tr>
<tr class="separator:a209d15915115be886e31a86e8f32e172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad656df57555cc0c42b226b0a76c6026e" id="r_ad656df57555cc0c42b226b0a76c6026e"><td class="memItemLeft" align="right" valign="top"><a id="ad656df57555cc0c42b226b0a76c6026e" name="ad656df57555cc0c42b226b0a76c6026e"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>TRPC_DYEING_KEY</b> [] = &quot;trpc-dyeing-key&quot;</td></tr>
<tr class="memdesc:ad656df57555cc0c42b226b0a76c6026e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dyeing key. <br /></td></tr>
<tr class="separator:ad656df57555cc0c42b226b0a76c6026e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba232c0bc7d5b3911a48b9868eb6afb" id="r_a1ba232c0bc7d5b3911a48b9868eb6afb"><td class="memItemLeft" align="right" valign="top"><a id="a1ba232c0bc7d5b3911a48b9868eb6afb" name="a1ba232c0bc7d5b3911a48b9868eb6afb"></a>
constexpr RpcCallType&#160;</td><td class="memItemRight" valign="bottom"><b>kUnaryCall</b> {0}</td></tr>
<tr class="memdesc:a1ba232c0bc7d5b3911a48b9868eb6afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple RPC where the client sends a request to the server and waits for a response to come back, just like a normal function call. <br /></td></tr>
<tr class="separator:a1ba232c0bc7d5b3911a48b9868eb6afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8f505cbff4bc6e50df74c99b9273cd" id="r_a5a8f505cbff4bc6e50df74c99b9273cd"><td class="memItemLeft" align="right" valign="top"><a id="a5a8f505cbff4bc6e50df74c99b9273cd" name="a5a8f505cbff4bc6e50df74c99b9273cd"></a>
constexpr RpcCallType&#160;</td><td class="memItemRight" valign="bottom"><b>kOnewayCall</b> {1}</td></tr>
<tr class="memdesc:a5a8f505cbff4bc6e50df74c99b9273cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple RPC where the client only sends a request to the server, but does not wait for a response to come back. <br /></td></tr>
<tr class="separator:a5a8f505cbff4bc6e50df74c99b9273cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed05533b2ed2fddc8c48c40637cf0473" id="r_aed05533b2ed2fddc8c48c40637cf0473"><td class="memItemLeft" align="right" valign="top">constexpr RpcCallType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#aed05533b2ed2fddc8c48c40637cf0473">kClientStreamingCall</a> {2}</td></tr>
<tr class="memdesc:aed05533b2ed2fddc8c48c40637cf0473"><td class="mdescLeft">&#160;</td><td class="mdescRight">A client-side streaming RPC where the client writes a sequence of messages and sends them to the server, again using a provided stream.  <br /></td></tr>
<tr class="separator:aed05533b2ed2fddc8c48c40637cf0473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2a8d4d1556a94136f266f1c7e888e0" id="r_a4b2a8d4d1556a94136f266f1c7e888e0"><td class="memItemLeft" align="right" valign="top">constexpr RpcCallType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#a4b2a8d4d1556a94136f266f1c7e888e0">kServerStreamingCall</a> {3}</td></tr>
<tr class="memdesc:a4b2a8d4d1556a94136f266f1c7e888e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A server-side streaming RPC where the client sends a request to the server and gets a stream to read a sequence of message back.  <br /></td></tr>
<tr class="separator:a4b2a8d4d1556a94136f266f1c7e888e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae329f46884a0566f81376f2b6fb2c07e" id="r_ae329f46884a0566f81376f2b6fb2c07e"><td class="memItemLeft" align="right" valign="top">constexpr RpcCallType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrpc.html#ae329f46884a0566f81376f2b6fb2c07e">kBidirectionalStreamingCall</a> {4}</td></tr>
<tr class="memdesc:ae329f46884a0566f81376f2b6fb2c07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional streaming RPC where both sides send a sequence of messages using a read-write stream.  <br /></td></tr>
<tr class="separator:ae329f46884a0566f81376f2b6fb2c07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af462dec9e4a579f96e9fc71f511fe60b" id="r_af462dec9e4a579f96e9fc71f511fe60b"><td class="memItemLeft" align="right" valign="top"><a id="af462dec9e4a579f96e9fc71f511fe60b" name="af462dec9e4a579f96e9fc71f511fe60b"></a>
const <a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultStatus</b> {0, &quot;&quot;}</td></tr>
<tr class="separator:af462dec9e4a579f96e9fc71f511fe60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff03ee90d5d9bf7cfaf880160ed724de" id="r_aff03ee90d5d9bf7cfaf880160ed724de"><td class="memItemLeft" align="right" valign="top"><a id="aff03ee90d5d9bf7cfaf880160ed724de" name="aff03ee90d5d9bf7cfaf880160ed724de"></a>
const <a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kSuccStatus</b> {0, &quot;&quot;}</td></tr>
<tr class="separator:aff03ee90d5d9bf7cfaf880160ed724de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89407b5e555da2d614f07b8f3de77a3f" id="r_a89407b5e555da2d614f07b8f3de77a3f"><td class="memItemLeft" align="right" valign="top"><a id="a89407b5e555da2d614f07b8f3de77a3f" name="a89407b5e555da2d614f07b8f3de77a3f"></a>
const <a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kUnknownErrorStatus</b> {-99999, -99999, &quot;unknown error&quot;}</td></tr>
<tr class="separator:a89407b5e555da2d614f07b8f3de77a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b4216038004f9503c0d312ff1fd69f" id="r_aa0b4216038004f9503c0d312ff1fd69f"><td class="memItemLeft" align="right" valign="top"><a id="aa0b4216038004f9503c0d312ff1fd69f" name="aa0b4216038004f9503c0d312ff1fd69f"></a>
const <a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kStreamRstStatus</b> {-97, 0, &quot;stream reset&quot;}</td></tr>
<tr class="separator:aa0b4216038004f9503c0d312ff1fd69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf16bb3c42bb80c3ca50bc7c645474" id="r_a68bf16bb3c42bb80c3ca50bc7c645474"><td class="memItemLeft" align="right" valign="top"><a id="a68bf16bb3c42bb80c3ca50bc7c645474" name="a68bf16bb3c42bb80c3ca50bc7c645474"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>kRetryHedgingLimitFilter</b> [] = &quot;retry_hedging_limit&quot;</td></tr>
<tr class="separator:a68bf16bb3c42bb80c3ca50bc7c645474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed119972f04bee54316bf883eddf0d37" id="r_aed119972f04bee54316bf883eddf0d37"><td class="memItemLeft" align="right" valign="top"><a id="aed119972f04bee54316bf883eddf0d37" name="aed119972f04bee54316bf883eddf0d37"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultRetryHedgingTokensNum</b> = 100</td></tr>
<tr class="separator:aed119972f04bee54316bf883eddf0d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719e1aa38b990727c1136c68931eb625" id="r_a719e1aa38b990727c1136c68931eb625"><td class="memItemLeft" align="right" valign="top"><a id="a719e1aa38b990727c1136c68931eb625" name="a719e1aa38b990727c1136c68931eb625"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultRetryHedgingTokenRatio</b> = 10</td></tr>
<tr class="separator:a719e1aa38b990727c1136c68931eb625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58a426343daf44b10b6f79db462f54f" id="r_ac58a426343daf44b10b6f79db462f54f"><td class="memItemLeft" align="right" valign="top"><a id="ac58a426343daf44b10b6f79db462f54f" name="ac58a426343daf44b10b6f79db462f54f"></a>
constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>kServerFilterPrefix</b> = 0x80</td></tr>
<tr class="memdesc:ac58a426343daf44b10b6f79db462f54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The prefix for server filter points, it allows for a maximum of 128 server filter points. <br /></td></tr>
<tr class="separator:ac58a426343daf44b10b6f79db462f54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2c6e0dda991ab8f837c6568a2176a4" id="r_a0a2c6e0dda991ab8f837c6568a2176a4"><td class="memItemLeft" align="right" valign="top"><a id="a0a2c6e0dda991ab8f837c6568a2176a4" name="a0a2c6e0dda991ab8f837c6568a2176a4"></a>
constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>kServerFilterMask</b> = 0x7f</td></tr>
<tr class="memdesc:a0a2c6e0dda991ab8f837c6568a2176a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mask for server filter points. <br /></td></tr>
<tr class="separator:a0a2c6e0dda991ab8f837c6568a2176a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae28e38c4e292e111252e0176e45e10" id="r_a7ae28e38c4e292e111252e0176e45e10"><td class="memItemLeft" align="right" valign="top"><a id="a7ae28e38c4e292e111252e0176e45e10" name="a7ae28e38c4e292e111252e0176e45e10"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kFilterNum</b> = 20</td></tr>
<tr class="separator:a7ae28e38c4e292e111252e0176e45e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2658324ee9086f8e8b046aaf53ee786" id="r_ae2658324ee9086f8e8b046aaf53ee786"><td class="memItemLeft" align="right" valign="top"><a id="ae2658324ee9086f8e8b046aaf53ee786" name="ae2658324ee9086f8e8b046aaf53ee786"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kFilterTypeNum</b> = kFilterNum / 2</td></tr>
<tr class="separator:ae2658324ee9086f8e8b046aaf53ee786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eaaba1c5eb7b196dbfde25e69b4a21" id="r_a15eaaba1c5eb7b196dbfde25e69b4a21"><td class="memItemLeft" align="right" valign="top"><a id="a15eaaba1c5eb7b196dbfde25e69b4a21" name="a15eaaba1c5eb7b196dbfde25e69b4a21"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kMetricsCallerSource</b> = 0</td></tr>
<tr class="separator:a15eaaba1c5eb7b196dbfde25e69b4a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d32e1626327f773c549ac1e13c784c" id="r_a46d32e1626327f773c549ac1e13c784c"><td class="memItemLeft" align="right" valign="top"><a id="a46d32e1626327f773c549ac1e13c784c" name="a46d32e1626327f773c549ac1e13c784c"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kMetricsCalleeSource</b> = 1</td></tr>
<tr class="separator:a46d32e1626327f773c549ac1e13c784c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94653b1a43093cbe514eeec10aa147ee" id="r_a94653b1a43093cbe514eeec10aa147ee"><td class="memItemLeft" align="right" valign="top"><a id="a94653b1a43093cbe514eeec10aa147ee" name="a94653b1a43093cbe514eeec10aa147ee"></a>
constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>kInvalidEndpointId</b> = UINT64_MAX</td></tr>
<tr class="memdesc:a94653b1a43093cbe514eeec10aa147ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid endpoint ID. <br /></td></tr>
<tr class="separator:a94653b1a43093cbe514eeec10aa147ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc859a00ea914f6f47f545005b81d85e" id="r_afc859a00ea914f6f47f545005b81d85e"><td class="memItemLeft" align="right" valign="top"><a id="afc859a00ea914f6f47f545005b81d85e" name="afc859a00ea914f6f47f545005b81d85e"></a>
constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>kSeparate</b> = &quot;separate&quot;</td></tr>
<tr class="separator:afc859a00ea914f6f47f545005b81d85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc56b52b975330b3dd4560bbc8cd79c1" id="r_adc56b52b975330b3dd4560bbc8cd79c1"><td class="memItemLeft" align="right" valign="top"><a id="adc56b52b975330b3dd4560bbc8cd79c1" name="adc56b52b975330b3dd4560bbc8cd79c1"></a>
constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>kMerge</b> = &quot;merge&quot;</td></tr>
<tr class="separator:adc56b52b975330b3dd4560bbc8cd79c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab483e000391d5af4dc260fa7becb1f52" id="r_ab483e000391d5af4dc260fa7becb1f52"><td class="memItemLeft" align="right" valign="top"><a id="ab483e000391d5af4dc260fa7becb1f52" name="ab483e000391d5af4dc260fa7becb1f52"></a>
constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>kFiber</b> = &quot;fiber&quot;</td></tr>
<tr class="separator:ab483e000391d5af4dc260fa7becb1f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cf330481357787abd0ddf8f78df873" id="r_a79cf330481357787abd0ddf8f78df873"><td class="memItemLeft" align="right" valign="top"><a id="a79cf330481357787abd0ddf8f78df873" name="a79cf330481357787abd0ddf8f78df873"></a>
constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>kDefault</b> = &quot;default&quot;</td></tr>
<tr class="separator:a79cf330481357787abd0ddf8f78df873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa2acfc79bf8facf0472e8b5e905149" id="r_a9fa2acfc79bf8facf0472e8b5e905149"><td class="memItemLeft" align="right" valign="top"><a id="a9fa2acfc79bf8facf0472e8b5e905149" name="a9fa2acfc79bf8facf0472e8b5e905149"></a>
constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>kSeparateAdminInstance</b> = &quot;trpc_separate_admin_instance&quot;</td></tr>
<tr class="memdesc:a9fa2acfc79bf8facf0472e8b5e905149"><td class="mdescLeft">&#160;</td><td class="mdescRight">the name of the threading model used by admin service <br /></td></tr>
<tr class="separator:a9fa2acfc79bf8facf0472e8b5e905149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74ac7c5a9b5bc9e77dc07c15eb2c390" id="r_ac74ac7c5a9b5bc9e77dc07c15eb2c390"><td class="memItemLeft" align="right" valign="top"><a id="ac74ac7c5a9b5bc9e77dc07c15eb2c390" name="ac74ac7c5a9b5bc9e77dc07c15eb2c390"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_align_v</b> = alignof(max_align_t)</td></tr>
<tr class="separator:ac74ac7c5a9b5bc9e77dc07c15eb2c390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce39fed72f942212e6379751df90840" id="r_a9ce39fed72f942212e6379751df90840"><td class="memItemLeft" align="right" valign="top"><a id="a9ce39fed72f942212e6379751df90840" name="a9ce39fed72f942212e6379751df90840"></a>
constexpr struct <a class="el" href="structtrpc_1_1ref__ptr__t.html">trpc::ref_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ref_ptr</b></td></tr>
<tr class="separator:a9ce39fed72f942212e6379751df90840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84845d8886a8c2c4109abe4fc8abd48" id="r_ad84845d8886a8c2c4109abe4fc8abd48"><td class="memItemLeft" align="right" valign="top"><a id="ad84845d8886a8c2c4109abe4fc8abd48" name="ad84845d8886a8c2c4109abe4fc8abd48"></a>
constexpr struct <a class="el" href="structtrpc_1_1adopt__ptr__t.html">trpc::adopt_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>adopt_ptr</b></td></tr>
<tr class="separator:ad84845d8886a8c2c4109abe4fc8abd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Primary namespace of tRPC-Cpp. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a110a4d0f8a2121d80262036f4eb57333" name="a110a4d0f8a2121d80262036f4eb57333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110a4d0f8a2121d80262036f4eb57333">&#9670;&#160;</a></span>MakeClientContextCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetrpc.html#a110a4d0f8a2121d80262036f4eb57333">trpc::MakeClientContextCallback</a> = typedef std::function&lt;void(const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a>&amp;, <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is used by plugin developers to register how to set the contents of the server context into the client context when create clientcontext using MakeClientContext (no thread-safe). </p>
<p>For example, a tracing plugin may use this to register how to set the span information in the client context. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a30ad6719274d32670d65731183e4db12" name="a30ad6719274d32670d65731183e4db12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ad6719274d32670d65731183e4db12">&#9670;&#160;</a></span>FilterPoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12">trpc::FilterPoint</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of filter points : including pre and post filter points (there are paired). </p>
<p>The index of the paired filter points is (index, index+1), where index is an even number. </p><dl class="section note"><dt>Note</dt><dd>The number of filter points between the client and server must be consistent. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12a468638263772223935d19ee323991d00" name="a30ad6719274d32670d65731183e4db12a468638263772223935d19ee323991d00"></a>CLIENT_PRE_RPC_INVOKE&#160;</td><td class="fielddoc"><p>Before makes client RPC call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12a9e70d6ca9b4d13184e73eff303cfbeab" name="a30ad6719274d32670d65731183e4db12a9e70d6ca9b4d13184e73eff303cfbeab"></a>CLIENT_POST_RPC_INVOKE&#160;</td><td class="fielddoc"><p>After makes client RPC call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12acc68a7448829d47b0c939713220799dd" name="a30ad6719274d32670d65731183e4db12acc68a7448829d47b0c939713220799dd"></a>CLIENT_PRE_SEND_MSG&#160;</td><td class="fielddoc"><p>Before client sends the RPC request message. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12aeaaca82fa04a0b6906b6c0e752f17f22" name="a30ad6719274d32670d65731183e4db12aeaaca82fa04a0b6906b6c0e752f17f22"></a>CLIENT_POST_RECV_MSG&#160;</td><td class="fielddoc"><p>After client receives the RPC response message. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12a7d8556bd1a2d98d38f550472503a3ee7" name="a30ad6719274d32670d65731183e4db12a7d8556bd1a2d98d38f550472503a3ee7"></a>CLIENT_PRE_SCHED_SEND_MSG&#160;</td><td class="fielddoc"><p>Before schedules client's sending request for processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12aeabbe66a61b0f99dd77b2d3b464dc27d" name="a30ad6719274d32670d65731183e4db12aeabbe66a61b0f99dd77b2d3b464dc27d"></a>CLIENT_POST_SCHED_SEND_MSG&#160;</td><td class="fielddoc"><p>After schedules client's sending request for processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12aab5281da4996c5e2a4c77a8f8d15e1f1" name="a30ad6719274d32670d65731183e4db12aab5281da4996c5e2a4c77a8f8d15e1f1"></a>CLIENT_PRE_SCHED_RECV_MSG&#160;</td><td class="fielddoc"><p>Before schedules client's recevied response for processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12a89019049366801d06a98a5c6ab548cff" name="a30ad6719274d32670d65731183e4db12a89019049366801d06a98a5c6ab548cff"></a>CLIENT_POST_SCHED_RECV_MSG&#160;</td><td class="fielddoc"><p>After schedules client's recevied response for processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12aa93b97fed9510562ec49f8034c014f2b" name="a30ad6719274d32670d65731183e4db12aa93b97fed9510562ec49f8034c014f2b"></a>CLIENT_PRE_IO_SEND_MSG&#160;</td><td class="fielddoc"><p>Before performs the I/O operation for sending request. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12ab9d702e318c326da14b1d857c9200475" name="a30ad6719274d32670d65731183e4db12ab9d702e318c326da14b1d857c9200475"></a>CLIENT_POST_IO_SEND_MSG&#160;</td><td class="fielddoc"><p>After performs the I/O operation for sending request. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12abd6fd09897fa541f57659891b4f359b4" name="a30ad6719274d32670d65731183e4db12abd6fd09897fa541f57659891b4f359b4"></a>SERVER_POST_RECV_MSG&#160;</td><td class="fielddoc"><p>After server receives the RPC request message. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12a43eb2a4cf2dc6fb7aa813a31a1d43d91" name="a30ad6719274d32670d65731183e4db12a43eb2a4cf2dc6fb7aa813a31a1d43d91"></a>SERVER_PRE_SEND_MSG&#160;</td><td class="fielddoc"><p>Before server sends the RPC response message. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12a6ec0fc1b12fa10e3f532be796a73b66e" name="a30ad6719274d32670d65731183e4db12a6ec0fc1b12fa10e3f532be796a73b66e"></a>SERVER_PRE_RPC_INVOKE&#160;</td><td class="fielddoc"><p>Before makes server RPC call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12a2fa2a8126a608a5adae5baacf51aebee" name="a30ad6719274d32670d65731183e4db12a2fa2a8126a608a5adae5baacf51aebee"></a>SERVER_POST_RPC_INVOKE&#160;</td><td class="fielddoc"><p>After makes server RPC call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12ab325e9e3e9b815bc2180b40f010abd0d" name="a30ad6719274d32670d65731183e4db12ab325e9e3e9b815bc2180b40f010abd0d"></a>SERVER_PRE_SCHED_RECV_MSG&#160;</td><td class="fielddoc"><p>Before schedules server's received request for processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12ade4430aabf079624c2d4a98bae8aa934" name="a30ad6719274d32670d65731183e4db12ade4430aabf079624c2d4a98bae8aa934"></a>SERVER_POST_SCHED_RECV_MSG&#160;</td><td class="fielddoc"><p>After schedules server's received request for processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12a7779da133e794f9f5adf0cc68e5c79c5" name="a30ad6719274d32670d65731183e4db12a7779da133e794f9f5adf0cc68e5c79c5"></a>SERVER_PRE_SCHED_SEND_MSG&#160;</td><td class="fielddoc"><p>Before schedules server's sending response for processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12a409fd855750b4f3b9b23350aa9b281a9" name="a30ad6719274d32670d65731183e4db12a409fd855750b4f3b9b23350aa9b281a9"></a>SERVER_POST_SCHED_SEND_MSG&#160;</td><td class="fielddoc"><p>After schedules server's sending response for processing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12ada27b10ff257bdf112b0b856f9e105ad" name="a30ad6719274d32670d65731183e4db12ada27b10ff257bdf112b0b856f9e105ad"></a>SERVER_PRE_IO_SEND_MSG&#160;</td><td class="fielddoc"><p>Before performs the I/O operation for sending response. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30ad6719274d32670d65731183e4db12aadff508c04f22a3a5046e149b2cbd004" name="a30ad6719274d32670d65731183e4db12aadff508c04f22a3a5046e149b2cbd004"></a>SERVER_POST_IO_SEND_MSG&#160;</td><td class="fielddoc"><p>After performs the I/O operation for sending response. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad2843836703e68d6a142b786a0876023" name="ad2843836703e68d6a142b786a0876023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2843836703e68d6a142b786a0876023">&#9670;&#160;</a></span>FilterStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacetrpc.html#ad2843836703e68d6a142b786a0876023">trpc::FilterStatus</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>filter execution status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad2843836703e68d6a142b786a0876023a2f453cfe638e57e27bb0c9512436111e" name="ad2843836703e68d6a142b786a0876023a2f453cfe638e57e27bb0c9512436111e"></a>CONTINUE&#160;</td><td class="fielddoc"><p>Continue to execute next filter. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad2843836703e68d6a142b786a0876023a59b228d9fec9b88833bfe5d812ed8ad4" name="ad2843836703e68d6a142b786a0876023a59b228d9fec9b88833bfe5d812ed8ad4"></a>REJECT&#160;</td><td class="fielddoc"><p>Interrupt the execution of the filter chain. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1a27838d5faa6ad90bb041fb7aeded5c" name="a1a27838d5faa6ad90bb041fb7aeded5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a27838d5faa6ad90bb041fb7aeded5c">&#9670;&#160;</a></span>LimitRetCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetrpc.html#a1a27838d5faa6ad90bb041fb7aeded5c">trpc::LimitRetCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return codes of rate limiting interface. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1a27838d5faa6ad90bb041fb7aeded5cac324442010758817b56071603c9114a2" name="a1a27838d5faa6ad90bb041fb7aeded5cac324442010758817b56071603c9114a2"></a>kLimitOK&#160;</td><td class="fielddoc"><p>No rate limiting. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1a27838d5faa6ad90bb041fb7aeded5ca11edb94b73657cb828be90b8aea80101" name="a1a27838d5faa6ad90bb041fb7aeded5ca11edb94b73657cb828be90b8aea80101"></a>kLimitError&#160;</td><td class="fielddoc"><p>Error occurred during rate limiting execution or no rate limiting is needed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1a27838d5faa6ad90bb041fb7aeded5ca730e524ed3269bc7351eb1dae327d24b" name="a1a27838d5faa6ad90bb041fb7aeded5ca730e524ed3269bc7351eb1dae327d24b"></a>kLimitReject&#160;</td><td class="fielddoc"><p>Trigger rate limiting and reject the request. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0aabc4f119fc1b5de072cd27136d33b4" name="a0aabc4f119fc1b5de072cd27136d33b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aabc4f119fc1b5de072cd27136d33b4">&#9670;&#160;</a></span>MetricsPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetrpc.html#a0aabc4f119fc1b5de072cd27136d33b4">trpc::MetricsPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statistical strategy. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0aabc4f119fc1b5de072cd27136d33b4a838eb9b41ff3af23778d6dc81153a296" name="a0aabc4f119fc1b5de072cd27136d33b4a838eb9b41ff3af23778d6dc81153a296"></a>SET&#160;</td><td class="fielddoc"><p>Overwrite the statistical value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0aabc4f119fc1b5de072cd27136d33b4a299005135f31b7fee9e679d24f13c0d3" name="a0aabc4f119fc1b5de072cd27136d33b4a299005135f31b7fee9e679d24f13c0d3"></a>SUM&#160;</td><td class="fielddoc"><p>Calculate the sum value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0aabc4f119fc1b5de072cd27136d33b4a1d2fc85492c4e0f335d9a0638d0074e9" name="a0aabc4f119fc1b5de072cd27136d33b4a1d2fc85492c4e0f335d9a0638d0074e9"></a>AVG&#160;</td><td class="fielddoc"><p>Calculate the mean value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0aabc4f119fc1b5de072cd27136d33b4ae8bc50fb111ced7281df896367feccb9" name="a0aabc4f119fc1b5de072cd27136d33b4ae8bc50fb111ced7281df896367feccb9"></a>MAX&#160;</td><td class="fielddoc"><p>Calculate the maximum value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0aabc4f119fc1b5de072cd27136d33b4a1e4f2700a908ecb0196b0e55aa130528" name="a0aabc4f119fc1b5de072cd27136d33b4a1e4f2700a908ecb0196b0e55aa130528"></a>MIN&#160;</td><td class="fielddoc"><p>Calculate the minimum value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0aabc4f119fc1b5de072cd27136d33b4a33376d99579f3a1214ffde85c963364f" name="a0aabc4f119fc1b5de072cd27136d33b4a33376d99579f3a1214ffde85c963364f"></a>MID&#160;</td><td class="fielddoc"><p>Calculate the median value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0aabc4f119fc1b5de072cd27136d33b4adac8002e407d444f0e453d3a77eeced9" name="a0aabc4f119fc1b5de072cd27136d33b4adac8002e407d444f0e453d3a77eeced9"></a>QUANTILES&#160;</td><td class="fielddoc"><p>Calculate the quartiles. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0aabc4f119fc1b5de072cd27136d33b4ac7f2951ad3416d306e490f79ce2b5c1d" name="a0aabc4f119fc1b5de072cd27136d33b4ac7f2951ad3416d306e490f79ce2b5c1d"></a>HISTOGRAM&#160;</td><td class="fielddoc"><p>Calculate the histogram. </p>
</td></tr>
</table>

</div>
</div>
<a id="ac475587e42e2de2bba3fb22ab3455999" name="ac475587e42e2de2bba3fb22ab3455999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac475587e42e2de2bba3fb22ab3455999">&#9670;&#160;</a></span>SelectorPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacetrpc.html#ac475587e42e2de2bba3fb22ab3455999">trpc::SelectorPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Routing selection policy. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac475587e42e2de2bba3fb22ab3455999abc21e6484530fc9d0313cb816b733396" name="ac475587e42e2de2bba3fb22ab3455999abc21e6484530fc9d0313cb816b733396"></a>ONE&#160;</td><td class="fielddoc"><p>Select one. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac475587e42e2de2bba3fb22ab3455999a5fb1f955b45e38e31789286a1790398d" name="ac475587e42e2de2bba3fb22ab3455999a5fb1f955b45e38e31789286a1790398d"></a>ALL&#160;</td><td class="fielddoc"><p>Select all. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac475587e42e2de2bba3fb22ab3455999a8c52684db8f49511e9b44471716bf164" name="ac475587e42e2de2bba3fb22ab3455999a8c52684db8f49511e9b44471716bf164"></a>SET&#160;</td><td class="fielddoc"><p>Select according to set policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac475587e42e2de2bba3fb22ab3455999a0dfcc4a2577af287e948561de2e93e0e" name="ac475587e42e2de2bba3fb22ab3455999a0dfcc4a2577af287e948561de2e93e0e"></a>IDC&#160;</td><td class="fielddoc"><p>Select according to proximity policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac475587e42e2de2bba3fb22ab3455999a65f405ff27981239b3c296a487786b85" name="ac475587e42e2de2bba3fb22ab3455999a65f405ff27981239b3c296a487786b85"></a>MULTIPLE&#160;</td><td class="fielddoc"><p>Select multiple. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a283fc1da9109c60e49af359fa39f8068" name="a283fc1da9109c60e49af359fa39f8068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283fc1da9109c60e49af359fa39f8068">&#9670;&#160;</a></span>BackFillServerTransInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::BackFillServerTransInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>client_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>server_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the scenario of a route service, obtain the transparent transmission information replied by the backend node, fill it back to the relay service, and then return it to the frontend node by the relay service. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client_context</td><td>client context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">server_context</td><td>server context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9da1c8975bef8d8d483c4cfe0cde9ccc" name="a9da1c8975bef8d8d483c4cfe0cde9ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da1c8975bef8d8d483c4cfe0cde9ccc">&#9670;&#160;</a></span>BatchStartFiberDetached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trpc::BatchStartFiberDetached </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>start_procs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Batch Create fibers and run all. </p>
<dl class="section note"><dt>Note</dt><dd>It's all going to be all or none </dd></dl>

</div>
</div>
<a id="a30d22c752d7333c1d96094a8ffb82220" name="a30d22c752d7333c1d96094a8ffb82220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d22c752d7333c1d96094a8ffb82220">&#9670;&#160;</a></span>CreateBufferBlockSlow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1object__pool_1_1_lw_unique_ptr.html">object_pool::LwUniquePtr</a>&lt; <a class="el" href="structtrpc_1_1_buffer_block.html">BufferBlock</a> &gt; trpc::CreateBufferBlockSlow </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of size <code>size</code> from <code>ptr</code> to a <a class="el" href="structtrpc_1_1_buffer_block.html" title="Belongs to a middle layer object, mainly used by NoncontiguousBuffer.">BufferBlock</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The address of the data being copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data being copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structtrpc_1_1_buffer_block.html" title="Belongs to a middle layer object, mainly used by NoncontiguousBuffer.">BufferBlock</a> object included content of <code>ptr</code> </dd></dl>

</div>
</div>
<a id="ac1301e2a724a6f90b0d2de3f01d725a5" name="ac1301e2a724a6f90b0d2de3f01d725a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1301e2a724a6f90b0d2de3f01d725a5">&#9670;&#160;</a></span>CreateBufferBlockSlow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1object__pool_1_1_lw_unique_ptr.html">object_pool::LwUniquePtr</a>&lt; <a class="el" href="structtrpc_1_1_buffer_block.html">BufferBlock</a> &gt; trpc::CreateBufferBlockSlow </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the string to a <a class="el" href="structtrpc_1_1_buffer_block.html" title="Belongs to a middle layer object, mainly used by NoncontiguousBuffer.">BufferBlock</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A specified string object needed copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structtrpc_1_1_buffer_block.html" title="Belongs to a middle layer object, mainly used by NoncontiguousBuffer.">BufferBlock</a> object included content of <code>s</code> </dd></dl>

</div>
</div>
<a id="a89f0e1918294921dd71a8a5919d2335f" name="a89f0e1918294921dd71a8a5919d2335f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f0e1918294921dd71a8a5919d2335f">&#9670;&#160;</a></span>CreateBufferSlow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> trpc::CreateBufferSlow </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of <code>ptr</code> of size <code>size</code> to the <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The address of the data being copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data being copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> object that stores data of size <code>size</code> from <code>ptr</code>. </dd></dl>

</div>
</div>
<a id="ae311409b795db0390d414b0df18e0305" name="ae311409b795db0390d414b0df18e0305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae311409b795db0390d414b0df18e0305">&#9670;&#160;</a></span>CreateBufferSlow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> trpc::CreateBufferSlow </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the string to a <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string being copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> object that stores data of <code>s</code> </dd></dl>

</div>
</div>
<a id="a2bfe3315fa875dd98a4a65e114ba2cd2" name="a2bfe3315fa875dd98a4a65e114ba2cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfe3315fa875dd98a4a65e114ba2cd2">&#9670;&#160;</a></span>CreateFiberTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t trpc::CreateFiberTimer </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::time_point&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void(std::uint64_t)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two-stage timer creation, For internal use only. </p>
<p>DO NOT USE IT.</p>
<p>In certain case, you may want to store timer ID somewhere and access that ID in timer callback. Without this two-stage procedure, you need to synchronizes between timer-id-filling and timer-callback.</p>
<p>Timer ID returned must be detached or killed. Otherwise a leak will occur. </p>

</div>
</div>
<a id="aaf0c3b6c309ddeea5739d0ad15d5763a" name="aaf0c3b6c309ddeea5739d0ad15d5763a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0c3b6c309ddeea5739d0ad15d5763a">&#9670;&#160;</a></span>DoFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future trpc::DoFor </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute func for several times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>How many times do fun execute. </td></tr>
    <tr><td class="paramname">func</td><td>User func. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;&gt; Ready when completed, otherwise fails when func fails. </dd></dl>

</div>
</div>
<a id="adb0ed7ef8b61aea6c9442157ec6d70ea" name="adb0ed7ef8b61aea6c9442157ec6d70ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0ed7ef8b61aea6c9442157ec6d70ea">&#9670;&#160;</a></span>DoForEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Func , typename  = std::invoke_result_t&lt;Func, typename Container::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future trpc::DoForEach </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute func with each element in a container, in order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>For Partitial Specialization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Iterate over. </td></tr>
    <tr><td class="paramname">func</td><td>User function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;&gt; </dd></dl>

</div>
</div>
<a id="af3e510e63ee38f6f6d9941f21855b350" name="af3e510e63ee38f6f6d9941f21855b350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e510e63ee38f6f6d9941f21855b350">&#9670;&#160;</a></span>DoForEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future trpc::DoForEach </td>
          <td>(</td>
          <td class="paramtype">Iterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute func for every iterator in the range [begin, end), in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>First iterator. </td></tr>
    <tr><td class="paramname">end</td><td>Last iterator. </td></tr>
    <tr><td class="paramname">func</td><td>User function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;&gt; Ready when completed, otherwise failed when func fails. </dd></dl>

</div>
</div>
<a id="a6f9608847223f2ae284b6f6de062aa6e" name="a6f9608847223f2ae284b6f6de062aa6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9608847223f2ae284b6f6de062aa6e">&#9670;&#160;</a></span>DoUntil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename  = std::enable_if_t&lt;std::is_same_v&lt;std::invoke_result_t&lt;Func&gt;, Future&lt;bool&gt;&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future trpc::DoUntil </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute func repeatedly until function return a ready Future&lt;bool&gt; with false. </p>
<p>If the func returns an exception future, the loop will terminate immediately and return a same exception. </p><dl class="section return"><dt>Returns</dt><dd>Future&lt;&gt; Ready when stopped, otherwise fails when func failed. </dd></dl>

</div>
</div>
<a id="a671550f90c6358589f3fa90ac5790c76" name="a671550f90c6358589f3fa90ac5790c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671550f90c6358589f3fa90ac5790c76">&#9670;&#160;</a></span>DoUntil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stop , typename Func , typename R  = std::invoke_result_t&lt;Func&gt;, typename  = std::enable_if_t&lt;std::is_same_v&lt;std::invoke_result_t&lt;Stop&gt;, bool&gt;&gt;, typename  = std::enable_if_t&lt;is_future_v&lt;R&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future trpc::DoUntil </td>
          <td>(</td>
          <td class="paramtype">Stop &amp;&amp;&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute func repeatedly until stop function return true. </p>
<p>If the func returns an exception future, the loop will terminate immediately and return a same exception. Eachtime stop function runs before func. </p><dl class="section return"><dt>Returns</dt><dd>Future&lt;&gt; Ready when stopped, otherwise fails when func failed. </dd></dl>

</div>
</div>
<a id="acb0dc6c107683d6ba75ea4f6ab513d7b" name="acb0dc6c107683d6ba75ea4f6ab513d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0dc6c107683d6ba75ea4f6ab513d7b">&#9670;&#160;</a></span>DoWhile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Condition , typename Func , typename R  = typename std::invoke_result_t&lt;Func&gt;, typename  = std::enable_if_t&lt;std::is_same_v&lt;std::invoke_result_t&lt;Condition&gt;, bool&gt;&gt;, typename  = std::enable_if_t&lt;is_future_v&lt;R&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future trpc::DoWhile </td>
          <td>(</td>
          <td class="paramtype">Condition &amp;&amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute func repeatedly while cond function return true. </p>
<p>If the func returns an exception future, the loop will terminate immediately and return a same exception. Eachtime cond function runs before func. </p><dl class="section return"><dt>Returns</dt><dd>Future&lt;&gt; Ready when stopped, otherwise fails when func failed. </dd></dl>

</div>
</div>
<a id="ae5e1af894652159a23f334862ec13cd3" name="ae5e1af894652159a23f334862ec13cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e1af894652159a23f334862ec13cd3">&#9670;&#160;</a></span>DoWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Func , typename R  = typename std::invoke_result&lt;Func, T &amp;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R trpc::DoWith </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a object to heap memory, and hold it until func's future was resolved. </p>
<p>The object will be passed into func as lvalue reference. </p>

</div>
</div>
<a id="a7c96af6d310610e307458bdf8fb4ad8d" name="a7c96af6d310610e307458bdf8fb4ad8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c96af6d310610e307458bdf8fb4ad8d">&#9670;&#160;</a></span>DurationFromTsc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::nanoseconds trpc::DurationFromTsc </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read value of Tsc and return to caller </p>
<dl class="section note"><dt>Note</dt><dd>TSC is almost guaranteed not to synchronize among all cores (since you're likely running on a multi-chip system.). If you need such a timestamp, use <code>std::steady_clock</code> instead. TSC is suitable for situations where accuracy can be trade for speed.</dd></dl>
<p>Converts difference between two TSCs into <code>std::duration&lt;...&gt;</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the begin of TSCs </td></tr>
    <tr><td class="paramname">to</td><td>the end of TSCs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nanoseconds </dd></dl>

</div>
</div>
<a id="a0735ceb246ba673813630b8057d25cbb" name="a0735ceb246ba673813630b8057d25cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0735ceb246ba673813630b8057d25cbb">&#9670;&#160;</a></span>EnableFiberTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::EnableFiberTimer </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>timer_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable timer previously created via <code>CreateFiberTimer</code>. </p>
<dl class="section note"><dt>Note</dt><dd>For internal use only. DO NOT USE IT. </dd></dl>

</div>
</div>
<a id="a607ab3e196e71cd65dddf61bff7993d1" name="a607ab3e196e71cd65dddf61bff7993d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607ab3e196e71cd65dddf61bff7993d1">&#9670;&#160;</a></span>FiberSleepFor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void trpc::FiberSleepFor </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>expires_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>SleepFor</code> for durations other than <code>std::chrono::nanoseconds</code>. </p>
<dl class="section note"><dt>Note</dt><dd>It can be used in pthread context and fiber context. </dd></dl>

</div>
</div>
<a id="af4c4582fef555fe7dab66477314f8644" name="af4c4582fef555fe7dab66477314f8644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c4582fef555fe7dab66477314f8644">&#9670;&#160;</a></span>FiberSleepFor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::FiberSleepFor </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::nanoseconds &amp;&#160;</td>
          <td class="paramname"><em>expires_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block calling pthread or calling fiber for <code>expires_in</code>. </p>
<dl class="section note"><dt>Note</dt><dd>It can be used in pthread context and fiber context. </dd></dl>

</div>
</div>
<a id="a31a5373cea48f3f2edfb53b0de55ea80" name="a31a5373cea48f3f2edfb53b0de55ea80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a5373cea48f3f2edfb53b0de55ea80">&#9670;&#160;</a></span>FiberSleepUntil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::FiberSleepUntil </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::steady_clock::time_point &amp;&#160;</td>
          <td class="paramname"><em>expires_at</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block calling pthread or calling fiber until <code>expires_at</code>. </p>
<dl class="section note"><dt>Note</dt><dd>It can be used in pthread context and fiber context. </dd></dl>

</div>
</div>
<a id="af3cfb2a8dbb0c6a02a7b19df319648b2" name="af3cfb2a8dbb0c6a02a7b19df319648b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cfb2a8dbb0c6a02a7b19df319648b2">&#9670;&#160;</a></span>FiberSleepUntil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock , class Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void trpc::FiberSleepUntil </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>expires_at</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>SleepUntil</code> for clocks other than <code>std::steady_clock</code>. </p>
<dl class="section note"><dt>Note</dt><dd>It can be used in pthread context and fiber context. </dd></dl>

</div>
</div>
<a id="a039d231c805f5660aaf16bb898e4d77e" name="a039d231c805f5660aaf16bb898e4d77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039d231c805f5660aaf16bb898e4d77e">&#9670;&#160;</a></span>FiberYield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::FiberYield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield execution. </p>
<p>If there's no other fiber is ready to run, the caller will be rescheduled immediately. </p><dl class="section note"><dt>Note</dt><dd>It only uses in fiber runtime. </dd></dl>

</div>
</div>
<a id="a1dd048d40ab0ba907b3e102f0bf42da8" name="a1dd048d40ab0ba907b3e102f0bf42da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd048d40ab0ba907b3e102f0bf42da8">&#9670;&#160;</a></span>FlattenSlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trpc::FlattenSlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_bytes</em> = <code>std::numeric_limits&lt;&#160;std::size_t&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> to a string object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb</td><td>The <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> object being copied. </td></tr>
    <tr><td class="paramname">max_bytes</td><td>The maximum size of the data being copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string object that contains the data content of <code>max_bytes</code> bytes from <code>nb</code>. </dd></dl>

</div>
</div>
<a id="a6cdd8bda3736550d82d09ce6c902b705" name="a6cdd8bda3736550d82d09ce6c902b705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdd8bda3736550d82d09ce6c902b705">&#9670;&#160;</a></span>FlattenSlowUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trpc::FlattenSlowUntil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_bytes</em> = <code>std::numeric_limits&lt;&#160;std::size_t&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the content of delim in nb. </p>
<p>If found, compare the position of the found content plus the size of delim with max_bytes and take the smaller value. Otherwise, copy the data of size <code>max_bytes</code> to a string and return it to the user. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb</td><td>The <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> object being copied. </td></tr>
    <tr><td class="paramname">delim</td><td>The target string being searched. </td></tr>
    <tr><td class="paramname">max_bytes</td><td>he maximum size of the data being copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string converted from a <code>nb</code> that contains the content of <code>delim</code>. </dd></dl>

</div>
</div>
<a id="ac691d2921e835345806cbd71e66ed8d8" name="ac691d2921e835345806cbd71e66ed8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac691d2921e835345806cbd71e66ed8d8">&#9670;&#160;</a></span>FlattenToSlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::FlattenToSlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy size bytes from <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html" title="Implementation of contiguous buffer NoncontiguousBuffer is composed of multiple contiguous memory blo...">NoncontiguousBuffer</a> to contiguous buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb</td><td>The source address of the data being copied. </td></tr>
    <tr><td class="paramname">buffer</td><td>The destination address of the data being copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data being copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller ensures that <code>nb.ByteSize()</code> is greater than <code>size</code>. </dd></dl>

</div>
</div>
<a id="ab65fd68ee212a7a59a269c9f9f0dc7cf" name="ab65fd68ee212a7a59a269c9f9f0dc7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65fd68ee212a7a59a269c9f9f0dc7cf">&#9670;&#160;</a></span>Format()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string trpc::Format </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>: <code>std::format</code> </dd></dl>

</div>
</div>
<a id="af913a7181ddb35698715bc5e482e896b" name="af913a7181ddb35698715bc5e482e896b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af913a7181ddb35698715bc5e482e896b">&#9670;&#160;</a></span>GetBlockMaxAvailableSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t trpc::GetBlockMaxAvailableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the available data area size in the Block. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the actual available size used to store data, which is the maximum amount of data that can be stored in data. </dd></dl>

</div>
</div>
<a id="a29052f2a896b59a8c75181f6012df7f8" name="a29052f2a896b59a8c75181f6012df7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29052f2a896b59a8c75181f6012df7f8">&#9670;&#160;</a></span>GetCurrentProcessorId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned trpc::GetCurrentProcessorId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current CPU ID. </p>
<dl class="section return"><dt>Returns</dt><dd>An unsigned type representing the CPU ID. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>FIXME: Naming is not consistent here, replace <code>CPU</code>s below with <code>Processor</code>. </dd></dl>

</div>
</div>
<a id="af65a4c7b98748e547c4c069b19d594a8" name="af65a4c7b98748e547c4c069b19d594a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65a4c7b98748e547c4c069b19d594a8">&#9670;&#160;</a></span>GetCurrentThreadAffinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned &gt; trpc::GetCurrentThreadAffinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CPU affinity of the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>cpu affinity of the current thread </dd></dl>

</div>
</div>
<a id="a3f1c0ada829779b2b04aac03a6943a5a" name="a3f1c0ada829779b2b04aac03a6943a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1c0ada829779b2b04aac03a6943a5a">&#9670;&#160;</a></span>GetHashIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t trpc::GetHashIndex </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the hash index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key value </td></tr>
    <tr><td class="paramname">mod</td><td>mod value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hash index </dd></dl>

</div>
</div>
<a id="aaf7be15d1f5d2499c00d486b7fbbfa03" name="aaf7be15d1f5d2499c00d486b7fbbfa03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7be15d1f5d2499c00d486b7fbbfa03">&#9670;&#160;</a></span>GetHashValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t trpc::GetHashValue </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the hash value corresponding to the key value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Key value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hash value </dd></dl>

</div>
</div>
<a id="a95e66df12b5ba86d583b735a21cc48b9" name="a95e66df12b5ba86d583b735a21cc48b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e66df12b5ba86d583b735a21cc48b9">&#9670;&#160;</a></span>GetLocalServerContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> trpc::GetLocalServerContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the context from a thread-private variable. </p>
<p>The private variable itself does not hold the context. The get operation must be used when the ctx is valid within its lifecycle. </p>

</div>
</div>
<a id="a2a4ac3db7bc11a9eac4e180e99a2f066" name="a2a4ac3db7bc11a9eac4e180e99a2f066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4ac3db7bc11a9eac4e180e99a2f066">&#9670;&#160;</a></span>GetMatchPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12">FilterPoint</a> trpc::GetMatchPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12">FilterPoint</a>&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the paired filter point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>filter point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point the paired filter point </dd></dl>

</div>
</div>
<a id="ae9ba2ab44a061e0ca72d1440f43be691" name="ae9ba2ab44a061e0ca72d1440f43be691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ba2ab44a061e0ca72d1440f43be691">&#9670;&#160;</a></span>GetMicroSeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t trpc::GetMicroSeconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timestamp in microseconds. </p>
<p>We use it to set timestamp during each progress. You can use it to calculate interval from which we set. </p><dl class="section note"><dt>Note</dt><dd>Use steady_clock by default. </dd></dl>

</div>
</div>
<a id="a13fb228a6922c63a5d42628e0396c7e6" name="a13fb228a6922c63a5d42628e0396c7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fb228a6922c63a5d42628e0396c7e6">&#9670;&#160;</a></span>GetMilliSeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t trpc::GetMilliSeconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timestamp in millseconds. </p>
<p>We use it to set timestamp during each progress. You can use it to calculate interval from which we set. </p><dl class="section note"><dt>Note</dt><dd>Use steady_clock by default. </dd></dl>

</div>
</div>
<a id="afb8d342e0325cf8c594b974d26a4ab6f" name="afb8d342e0325cf8c594b974d26a4ab6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8d342e0325cf8c594b974d26a4ab6f">&#9670;&#160;</a></span>GetNanoSeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t trpc::GetNanoSeconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timestamp in nanoseconds. </p>
<p>We use it to set timestamp during each progress. You can use it to calculate interval from which we set. </p><dl class="section note"><dt>Note</dt><dd>Use steady_clock by default. </dd></dl>

</div>
</div>
<a id="a2b768e7b06fd3368bb20b7e431b89c49" name="a2b768e7b06fd3368bb20b7e431b89c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b768e7b06fd3368bb20b7e431b89c49">&#9670;&#160;</a></span>GetNumberOfProcessorsAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t trpc::GetNumberOfProcessorsAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of available CPUs for the program. </p>
<dl class="section return"><dt>Returns</dt><dd>An std::size_t type representing the available CPU ID. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>CAUTION: If some processors are disabled, we may find processors whose ID is greater than number of processors. </dd></dl>

</div>
</div>
<a id="acc2f3a4fcd957b0e83a8f3909eb310dd" name="acc2f3a4fcd957b0e83a8f3909eb310dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2f3a4fcd957b0e83a8f3909eb310dd">&#9670;&#160;</a></span>GetNumberOfProcessorsConfigured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t trpc::GetNumberOfProcessorsConfigured </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of CPUs on the host machine. </p>
<dl class="section return"><dt>Returns</dt><dd>An std::size_t type representing the number of CPUs on the host machine. </dd></dl>

</div>
</div>
<a id="a2620fa099e6064e6aa05b683d8066ff5" name="a2620fa099e6064e6aa05b683d8066ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2620fa099e6064e6aa05b683d8066ff5">&#9670;&#160;</a></span>GetProcessCpuQuota()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double trpc::GetProcessCpuQuota </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool()&gt; &amp;&#160;</td>
          <td class="paramname"><em>check_container</em> = <code><a class="el" href="namespacetrpc.html#a4e4beeb72cc88fade2eac84b7d052be0">IsProcessInContainer</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the available CPU quota (number of cores) for the process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">check_container</td><td>Whether a process is running in a container environment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CPU quota (number of cores) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When running outside of a container, the available resources are determined by the machine's configuration. When running inside a container, the available resources are determined by the container's quota. </dd></dl>

</div>
</div>
<a id="ab3dce2f0ca94ccf9611c30d3aeb6f042" name="ab3dce2f0ca94ccf9611c30d3aeb6f042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3dce2f0ca94ccf9611c30d3aeb6f042">&#9670;&#160;</a></span>GetProcessMemoryQuota()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t trpc::GetProcessMemoryQuota </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool()&gt; &amp;&#160;</td>
          <td class="paramname"><em>check_container</em> = <code><a class="el" href="namespacetrpc.html#a4e4beeb72cc88fade2eac84b7d052be0">IsProcessInContainer</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the available memory quota (in bytes) for a process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">check_container</td><td>Whether a process is running in a container environment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory quota (in bytes) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When running outside of a container, the available resources are determined by the machine's configuration. When running inside a container, the available resources are determined by the container's quota. </dd></dl>

</div>
</div>
<a id="a60aec852909d2777984b80717f0b6afd" name="a60aec852909d2777984b80717f0b6afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60aec852909d2777984b80717f0b6afd">&#9670;&#160;</a></span>GetTrpcClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtrpc_1_1_trpc_client.html">TrpcClient</a> &gt; trpc::GetTrpcClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the global <a class="el" href="classtrpc_1_1_trpc_client.html" title="Implementation of trpc client.">TrpcClient</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The global client's 'Stop' and 'Destroy' method will be called by the framework internally. So you don't need to call it actively. </dd></dl>

</div>
</div>
<a id="a3f9eaf2c5c83876abc0ef5efb12f6061" name="a3f9eaf2c5c83876abc0ef5efb12f6061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9eaf2c5c83876abc0ef5efb12f6061">&#9670;&#160;</a></span>IEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trpc::IEquals </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Case insensitive-comparison. </p>
<dl class="section note"><dt>Note</dt><dd>Use <code>ICompare</code> instead when C++20 is available <code>ICompare</code> function is reserved and no implement for now, so we can implement it and return <code>std::strong_ordering</code> once C++20 is available. </dd></dl>

</div>
</div>
<a id="a47eb787840b413c95871db49333a5b99" name="a47eb787840b413c95871db49333a5b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47eb787840b413c95871db49333a5b99">&#9670;&#160;</a></span>IsInaccessibleProcessorPresent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trpc::IsInaccessibleProcessorPresent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there are any unavailable CPUs. </p>
<dl class="section return"><dt>Returns</dt><dd>A bool type, true if there are unavailable CPUs, false otherwise. </dd></dl>

</div>
</div>
<a id="a4e4beeb72cc88fade2eac84b7d052be0" name="a4e4beeb72cc88fade2eac84b7d052be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4beeb72cc88fade2eac84b7d052be0">&#9670;&#160;</a></span>IsProcessInContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trpc::IsProcessInContainer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the process is running in a container environment. </p>
<dl class="section return"><dt>Returns</dt><dd>true: Running in a container; false: Not running in a container. </dd></dl>

</div>
</div>
<a id="abd3f804b928683a742509c0ccdd8abce" name="abd3f804b928683a742509c0ccdd8abce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3f804b928683a742509c0ccdd8abce">&#9670;&#160;</a></span>IsProcessorAccessible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trpc::IsProcessorAccessible </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a specified CPU is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu</td><td>The specified CPU number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bool type, true if there are unavailable CPUs, false otherwise. </dd></dl>

</div>
</div>
<a id="ad757c37e30d4cce7c50e147b905664fb" name="ad757c37e30d4cce7c50e147b905664fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad757c37e30d4cce7c50e147b905664fb">&#9670;&#160;</a></span>KillFiberTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::KillFiberTimer </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>timer_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop timer. </p>
<dl class="section note"><dt>Note</dt><dd>You always need to call this unless the timer has been "detach"ed, otherwise it's a leak. </dd></dl>

</div>
</div>
<a id="a019fd0fdc6aa511d454313e44622eed0" name="a019fd0fdc6aa511d454313e44622eed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019fd0fdc6aa511d454313e44622eed0">&#9670;&#160;</a></span>MakeBlockRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_ref_ptr.html">RefPtr</a>&lt; <a class="el" href="structtrpc_1_1memory__pool_1_1disabled_1_1detail_1_1_block.html">memory_pool::MemBlock</a> &gt; trpc::MakeBlockRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrpc_1_1memory__pool_1_1disabled_1_1detail_1_1_block.html">memory_pool::MemBlock</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap the MemBlock object in a Refer object for ease of use later. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>MemBlock pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87706fce956605f16313beb49302411a" name="a87706fce956605f16313beb49302411a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87706fce956605f16313beb49302411a">&#9670;&#160;</a></span>MakeClientContext() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> trpc::MakeClientContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ServiceProxyPtr &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_trans_info</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create client context based on server context and service proxy(for rpc). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>server context </td></tr>
    <tr><td class="paramname">proxy</td><td>service proxy </td></tr>
    <tr><td class="paramname">with_trans_info</td><td>whether to copy the trans_info in the server context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>client context </dd></dl>

</div>
</div>
<a id="a80b8fe157dcbfcacf089fc4ccdd0e5d1" name="a80b8fe157dcbfcacf089fc4ccdd0e5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b8fe157dcbfcacf089fc4ccdd0e5d1">&#9670;&#160;</a></span>MakeClientContext() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> trpc::MakeClientContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ServiceProxyPtr &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProtocolPtr &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProtocolPtr &amp;&#160;</td>
          <td class="paramname"><em>rsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_trans_info</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create client context based on server context and service proxy(for non-rpc). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>server context </td></tr>
    <tr><td class="paramname">proxy</td><td>service proxy </td></tr>
    <tr><td class="paramname">req/rsp</td><td>which is created by <code>std::make_shared&lt;XxxProtocol&gt;()</code> </td></tr>
    <tr><td class="paramname">with_trans_info</td><td>whether to copy the trans_info in the server context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>client context </dd></dl>

</div>
</div>
<a id="a15f95a27a3dc0d0c5334abdffb399c16" name="a15f95a27a3dc0d0c5334abdffb399c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f95a27a3dc0d0c5334abdffb399c16">&#9670;&#160;</a></span>MakeClientContext() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> trpc::MakeClientContext </td>
          <td>(</td>
          <td class="paramtype">const ServiceProxyPtr &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create client context based on service proxy(for rpc). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>service proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>client context </dd></dl>

</div>
</div>
<a id="a59ce0689e2fce11a2528f5803fe69025" name="a59ce0689e2fce11a2528f5803fe69025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ce0689e2fce11a2528f5803fe69025">&#9670;&#160;</a></span>MakeClientContext() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> trpc::MakeClientContext </td>
          <td>(</td>
          <td class="paramtype">const ServiceProxyPtr &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProtocolPtr &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProtocolPtr &amp;&#160;</td>
          <td class="paramname"><em>rsp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create client context based on service proxy(for non-rpc). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>service proxy </td></tr>
    <tr><td class="paramname">req/rsp</td><td>which is created by <code>std::make_shared&lt;XxxProtocol&gt;()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>client context </dd></dl>

</div>
</div>
<a id="ae2ff2f296184128304bee24654eec014" name="ae2ff2f296184128304bee24654eec014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ff2f296184128304bee24654eec014">&#9670;&#160;</a></span>MakeServerContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> trpc::MakeServerContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create server context. </p>
<dl class="section return"><dt>Returns</dt><dd>server context </dd></dl>

</div>
</div>
<a id="afc909f5279f4ebcf092a4c290c9baa1d" name="afc909f5279f4ebcf092a4c290c9baa1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc909f5279f4ebcf092a4c290c9baa1d">&#9670;&#160;</a></span>MakeTransparentClientContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> trpc::MakeTransparentClientContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ServiceProxyPtr &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create client context for transparent transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>server context </td></tr>
    <tr><td class="paramname">proxy</td><td>service proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>client context </dd></dl>

</div>
</div>
<a id="abc29ec07c2130fb2e3339be8a38f169c" name="abc29ec07c2130fb2e3339be8a38f169c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc29ec07c2130fb2e3339be8a38f169c">&#9670;&#160;</a></span>ParseBindCoreConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trpc::ParseBindCoreConfig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bind_core_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bind_core_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the core binding configuration and check its validity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bind_core_conf</td><td>configuration string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bind_core_group</td><td>store the set of logical CPU numbers that the thread needs to be bound to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, otherwise return false. </dd></dl>

</div>
</div>
<a id="af1ec9ae2614be61186d05a815aca347a" name="af1ec9ae2614be61186d05a815aca347a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ec9ae2614be61186d05a815aca347a">&#9670;&#160;</a></span>Random() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = std::uint64_t, class  = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T trpc::Random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random value of type <code>T</code>. </p>
<p><code>T</code> may not be floating point types. </p><dl class="section return"><dt>Returns</dt><dd>A random value in range [std::numeric_limits&lt;T&gt;::min(),std::numeric_limits&lt;T&gt;::max()] (both inclusive). </dd></dl>

</div>
</div>
<a id="a4f270e365d0543d969da063e32e12497" name="a4f270e365d0543d969da063e32e12497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f270e365d0543d969da063e32e12497">&#9670;&#160;</a></span>Random() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T trpc::Random </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shorthand for <code>Random(0, max)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>the max value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random value </dd></dl>

</div>
</div>
<a id="aeed842dc7d05cf7707b6d0864a3082ef" name="aeed842dc7d05cf7707b6d0864a3082ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed842dc7d05cf7707b6d0864a3082ef">&#9670;&#160;</a></span>Random() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T trpc::Random </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random value in range [min, max] (inclusive) of type <code>T</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>the min value </td></tr>
    <tr><td class="paramname">max</td><td>the max value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random value generated are distributed uniformly. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>SimpleRandom</code> performs slightly better if multiple random values are needed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>: //common/random/simple_random.h. </dd></dl>

</div>
</div>
<a id="a4d77c84a58f3736615c6c8f3197e356d" name="a4d77c84a58f3736615c6c8f3197e356d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d77c84a58f3736615c6c8f3197e356d">&#9670;&#160;</a></span>ReadSystemClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::system_clock::time_point trpc::ReadSystemClock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>std::chrono::system_clock::now()</code>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>system_clock::time_point</code> </dd></dl>

</div>
</div>
<a id="a73f062046bb92ea512eeb0653ccce116" name="a73f062046bb92ea512eeb0653ccce116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f062046bb92ea512eeb0653ccce116">&#9670;&#160;</a></span>Repeat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename R  = std::invoke_result_t&lt;Func&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future trpc::Repeat </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute func repeatedly forever. </p>
<p>If the func returns an exception future, the loop will terminate immediately and return a same exception. </p><dl class="section return"><dt>Returns</dt><dd>Future&lt;&gt; Fails when func fails, never be ready. </dd></dl>

</div>
</div>
<a id="ad2a9748c76ef2b81fa39d133d2b5c275" name="ad2a9748c76ef2b81fa39d133d2b5c275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a9748c76ef2b81fa39d133d2b5c275">&#9670;&#160;</a></span>RoundUpPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t trpc::RoundUpPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round up to the nearest power of 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>input data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest power of 2 greater than n. </dd></dl>

</div>
</div>
<a id="a95544b09724701bc083c325f1195cb49" name="a95544b09724701bc083c325f1195cb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95544b09724701bc083c325f1195cb49">&#9670;&#160;</a></span>RunInFiberRuntime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int trpc::RunInFiberRuntime </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; int()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The entry function for the pure client program runs in fiber runtime. </p>
<dl class="section return"><dt>Returns</dt><dd>0: success, other: failed. </dd></dl>

</div>
</div>
<a id="aad67a015c2a1afaad7ab04b91702525d" name="aad67a015c2a1afaad7ab04b91702525d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad67a015c2a1afaad7ab04b91702525d">&#9670;&#160;</a></span>RunInThreadRuntime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int trpc::RunInThreadRuntime </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; int()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The entry function for the pure client program runs in thread(merge/separate) runtime. </p>
<dl class="section return"><dt>Returns</dt><dd>0: success, other: failed. </dd></dl>

</div>
</div>
<a id="a3a71e6f23f6fb89fe17288b5ab8997ec" name="a3a71e6f23f6fb89fe17288b5ab8997ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a71e6f23f6fb89fe17288b5ab8997ec">&#9670;&#160;</a></span>RunInTrpcRuntime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int trpc::RunInTrpcRuntime </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; int()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The entry function for the pure client program runs in trpc(fiber/merge/separate) runtime. </p>
<dl class="section return"><dt>Returns</dt><dd>0: success, other: failed. </dd></dl>

</div>
</div>
<a id="a824a2a1044132328f4cf60c3a1b678c7" name="a824a2a1044132328f4cf60c3a1b678c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824a2a1044132328f4cf60c3a1b678c7">&#9670;&#160;</a></span>SetCurrentThreadAffinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::SetCurrentThreadAffinity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>affinity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the CPU affinity of the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">affinity</td><td>cpu affinity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If set fails then it will trigger an assertion. </dd></dl>

</div>
</div>
<a id="af0fc8982d45386c1a9f7bce8ea904260" name="af0fc8982d45386c1a9f7bce8ea904260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fc8982d45386c1a9f7bce8ea904260">&#9670;&#160;</a></span>SetCurrentThreadName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::SetCurrentThreadName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current thread name displayed in the top command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the current thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If set fails then it will trigger an assertion. </dd></dl>

</div>
</div>
<a id="a41deb8e29150d75353ff6a4b91d88d66" name="a41deb8e29150d75353ff6a4b91d88d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41deb8e29150d75353ff6a4b91d88d66">&#9670;&#160;</a></span>SetFiberTimer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t trpc::SetFiberTimer </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::time_point&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a one-shot timer. </p>
<dl class="section note"><dt>Note</dt><dd>Timer ID returned by this method must be destroyed by <code>KillTimer</code>. It only uses in fiber runtime. </dd></dl>

</div>
</div>
<a id="a63c95295e70e9a5b4ca522314960e9ff" name="a63c95295e70e9a5b4ca522314960e9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c95295e70e9a5b4ca522314960e9ff">&#9670;&#160;</a></span>SetFiberTimer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t trpc::SetFiberTimer </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::time_point&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a periodic timer. </p>
<dl class="section note"><dt>Note</dt><dd>Timer ID returned by this method must be destroyed by <code>KillTimer</code>. It only uses in fiber runtime. </dd></dl>

</div>
</div>
<a id="a5b49ff60cf45fbb6ec2e6d853a8b1bf7" name="a5b49ff60cf45fbb6ec2e6d853a8b1bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b49ff60cf45fbb6ec2e6d853a8b1bf7">&#9670;&#160;</a></span>SetLocalServerContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::SetLocalServerContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_ref_ptr.html">ServerContextPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the context to a thread-private variable. </p>
<p>The private variable itself does not hold the context. The set operation must be used when the ctx is valid within its lifecycle. </p>

</div>
</div>
<a id="a1e50bad0b39f8b2d57dac348514cc704" name="a1e50bad0b39f8b2d57dac348514cc704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e50bad0b39f8b2d57dac348514cc704">&#9670;&#160;</a></span>StartFiberDetached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trpc::StartFiberDetached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtrpc_1_1_function.html">Function</a>&lt; void()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>start_proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a fiber and run it. </p>
<dl class="section note"><dt>Note</dt><dd>If the program creates too many fibers, system has not memory, it will return failure. <div class="fragment"><div class="line">examples:</div>
<div class="line"> </div>
<div class="line">1. create fiber and run it</div>
<div class="line"><span class="keywordtype">bool</span> start_fiber = <a class="code hl_function" href="namespacetrpc.html#a1e50bad0b39f8b2d57dac348514cc704">trpc::StartFiberDetached</a>([] { <span class="comment">// do your work here });</span></div>
<div class="line"><span class="keywordflow">if</span> (!start_fiber) { <span class="comment">// ... }</span></div>
<div class="line"> </div>
<div class="line">2. use with `<a class="code hl_class" href="classtrpc_1_1_fiber_latch.html">FiberLatch</a>` in fiber runtime</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classtrpc_1_1_fiber_latch.html">trpc::FiberLatch</a> l(1);</div>
<div class="line"><span class="keywordtype">bool</span> start_fiber = <a class="code hl_function" href="namespacetrpc.html#a1e50bad0b39f8b2d57dac348514cc704">trpc::StartFiberDetached</a>([] {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  l.CountDown();</div>
<div class="line">});</div>
<div class="line"><span class="keywordflow">if</span> (!start_fiber) {</div>
<div class="line">  l.CountDown();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;StartFiberDetached to execute task faild,please retry latter&quot;</span>;</div>
<div class="line">}</div>
<div class="line">l.Wait();</div>
<div class="line"> </div>
<div class="line">3. use with `<a class="code hl_class" href="classtrpc_1_1_latch.html">trpc::Latch</a>` outside fiber runtime</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classtrpc_1_1_latch.html">trpc::Latch</a> l(1);</div>
<div class="line"><span class="keywordtype">bool</span> start_fiber = <a class="code hl_function" href="namespacetrpc.html#a1e50bad0b39f8b2d57dac348514cc704">trpc::StartFiberDetached</a>([] {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  l.count_down();</div>
<div class="line">});</div>
<div class="line"><span class="keywordflow">if</span> (!start_fiber) {</div>
<div class="line">  l.count_down();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;StartFiberDetached to execute task faild, please retry latter&quot;</span>;</div>
<div class="line">}</div>
<div class="line">l.wait();</div>
<div class="ttc" id="aclasstrpc_1_1_fiber_latch_html"><div class="ttname"><a href="classtrpc_1_1_fiber_latch.html">trpc::FiberLatch</a></div><div class="ttdoc">Adaptive latch primitive for both fiber and pthread context.</div><div class="ttdef"><b>Definition</b> fiber_latch.h:20</div></div>
<div class="ttc" id="aclasstrpc_1_1_latch_html"><div class="ttname"><a href="classtrpc_1_1_latch.html">trpc::Latch</a></div><div class="ttdoc">A downward counter of type std::ptrdiff_t which can be used to synchronize threads.</div><div class="ttdef"><b>Definition</b> latch.h:23</div></div>
<div class="ttc" id="anamespacetrpc_html_a1e50bad0b39f8b2d57dac348514cc704"><div class="ttname"><a href="namespacetrpc.html#a1e50bad0b39f8b2d57dac348514cc704">trpc::StartFiberDetached</a></div><div class="ttdeci">bool StartFiberDetached(Function&lt; void()&gt; &amp;&amp;start_proc)</div><div class="ttdoc">Create a fiber and run it.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0b859883f0229a9b1446f4c7ba29bcd2" name="a0b859883f0229a9b1446f4c7ba29bcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b859883f0229a9b1446f4c7ba29bcd2">&#9670;&#160;</a></span>TryGetCurrentThreadAffinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int trpc::TryGetCurrentThreadAffinity </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>affinity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the CPU affinity of the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">affinity</td><td>cpu affinity of the current thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return 0 on success, other values on failure. </dd></dl>

</div>
</div>
<a id="af8de66e062aac2ce1202dea876833336" name="af8de66e062aac2ce1202dea876833336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8de66e062aac2ce1202dea876833336">&#9670;&#160;</a></span>TryParse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; trpc::TryParse </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try parse <code>s</code> as <code>T</code>. </p>
<dl class="section note"><dt>Note</dt><dd>To "specialize" <code><a class="el" href="namespacetrpc.html#af8de66e062aac2ce1202dea876833336" title="Try parse s as T.">trpc::TryParse</a></code> for your own type, either implement <code>TryParse</code> in a namespace that can be found via ADL, with signature like ... </dd></dl>

</div>
</div>
<a id="aecf2ad03c3081eb53b0d7f237dc3f90d" name="aecf2ad03c3081eb53b0d7f237dc3f90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf2ad03c3081eb53b0d7f237dc3f90d">&#9670;&#160;</a></span>TryParseProcesserList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::vector&lt; unsigned &gt; &gt; trpc::TryParseProcesserList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the CPU group configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The configuration, e.g. "1-10,21,-1". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Get the list of CPUs parsed from the configuration. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not sure if this is the right place to declare it though.. </dd></dl>

</div>
</div>
<a id="a4bd6f624a09d7825ec2938bb5a5ab1a6" name="a4bd6f624a09d7825ec2938bb5a5ab1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6f624a09d7825ec2938bb5a5ab1a6">&#9670;&#160;</a></span>TrySetCurrentThreadAffinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int trpc::TrySetCurrentThreadAffinity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>affinity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to set the CPU affinity of the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">affinity</td><td>cpu affinity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return 0 on success, other values on failure. </dd></dl>

</div>
</div>
<a id="a8be562910c25008d1388d7746bd7dc6b" name="a8be562910c25008d1388d7746bd7dc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be562910c25008d1388d7746bd7dc6b">&#9670;&#160;</a></span>WhenAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... FutsType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; std::tuple&lt; FutsType... &gt; &gt; trpc::WhenAll </td>
          <td>(</td>
          <td class="paramtype">FutsType &amp;&amp;...&#160;</td>
          <td class="paramname"><em>futs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waiting for multiple futures at same time. </p>
<p>When all futures were resolved(whatere ready or failed), this function's future will become ready with a tuple of all futures. </p><dl class="section return"><dt>Returns</dt><dd>Future&lt;std::tuple&lt;FutsType...&gt;&gt; </dd></dl>

</div>
</div>
<a id="a9d247a94f5e0e1bf9b63bbaf06b5ed55" name="a9d247a94f5e0e1bf9b63bbaf06b5ed55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d247a94f5e0e1bf9b63bbaf06b5ed55">&#9670;&#160;</a></span>WhenAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename FutureType  = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; std::vector&lt; FutureType &gt; &gt; trpc::WhenAll </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is as same as <a class="el" href="namespacetrpc.html#a8be562910c25008d1388d7746bd7dc6b">WhenAll(FutsType &amp;&amp;... futs)</a> , but accept two interators to set input futures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;std::vector&lt;FutureType&gt;&gt; </dd></dl>

</div>
</div>
<a id="ac185b04e5d7f1e91f012e0862c5b8b2a" name="ac185b04e5d7f1e91f012e0862c5b8b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac185b04e5d7f1e91f012e0862c5b8b2a">&#9670;&#160;</a></span>WhenAny()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename FutureType  = typename std::iterator_traits&lt;InputIterator&gt;::value_type, typename FutureValueType  = typename FutureType::TupleValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; size_t, FutureValueType &gt; trpc::WhenAny </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returned future turns resulted, when any input future ready or failed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FutureValueType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;size_t, FutureValueType&gt; </dd></dl>

</div>
</div>
<a id="ad0ec567d6529704ca03bce928ecf72df" name="ad0ec567d6529704ca03bce928ecf72df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ec567d6529704ca03bce928ecf72df">&#9670;&#160;</a></span>WhenAnyWithoutException()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename FutureType  = typename std::iterator_traits&lt;InputIterator&gt;::value_type, typename FutureValueType  = typename FutureType::TupleValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; size_t, FutureValueType &gt; trpc::WhenAnyWithoutException </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returned future turns resulted, when any input future ready or all input futures failed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First iterator. </td></tr>
    <tr><td class="paramname">last</td><td>Last iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;size_t, FutureValueType&gt; </dd></dl>

</div>
</div>
<a id="af713b2d105675f7dcbedf255faca66c3" name="af713b2d105675f7dcbedf255faca66c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af713b2d105675f7dcbedf255faca66c3">&#9670;&#160;</a></span>WithLock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Lock , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto trpc::WithLock </td>
          <td>(</td>
          <td class="paramtype">Lock *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute func with lock, and unlock when it's done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Reference to a Read/Write lock object, who offers Lock()/UnLock() syntax. </td></tr>
    <tr><td class="paramname">func</td><td>the lambda of user's work. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return whatever func returns, if func's return type is not Future&lt;&gt;, </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae329f46884a0566f81376f2b6fb2c07e" name="ae329f46884a0566f81376f2b6fb2c07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae329f46884a0566f81376f2b6fb2c07e">&#9670;&#160;</a></span>kBidirectionalStreamingCall</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RpcCallType trpc::kBidirectionalStreamingCall {4}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A bidirectional streaming RPC where both sides send a sequence of messages using a read-write stream. </p>
<p>The two streams operate independently, so clients and servers can read and write in whatever order they like. </p>

</div>
</div>
<a id="aed05533b2ed2fddc8c48c40637cf0473" name="aed05533b2ed2fddc8c48c40637cf0473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed05533b2ed2fddc8c48c40637cf0473">&#9670;&#160;</a></span>kClientStreamingCall</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RpcCallType trpc::kClientStreamingCall {2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A client-side streaming RPC where the client writes a sequence of messages and sends them to the server, again using a provided stream. </p>
<p>Once the client has finished writing messages, it waits for the server to read them all and returns its response. </p>

</div>
</div>
<a id="a4b2a8d4d1556a94136f266f1c7e888e0" name="a4b2a8d4d1556a94136f266f1c7e888e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2a8d4d1556a94136f266f1c7e888e0">&#9670;&#160;</a></span>kServerStreamingCall</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RpcCallType trpc::kServerStreamingCall {3}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A server-side streaming RPC where the client sends a request to the server and gets a stream to read a sequence of message back. </p>
<p>The client reads from the returned stream until there no more messages. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 28 2023 11:25:47 for tRPC-Cpp by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
