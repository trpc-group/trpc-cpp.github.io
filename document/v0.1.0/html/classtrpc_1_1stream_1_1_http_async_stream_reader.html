<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tRPC-Cpp: trpc::stream::HttpAsyncStreamReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tRPC-Cpp<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetrpc.html">trpc</a></li><li class="navelem"><a class="el" href="namespacetrpc_1_1stream.html">stream</a></li><li class="navelem"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader.html">HttpAsyncStreamReader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">trpc::stream::HttpAsyncStreamReader Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Asynchronous HTTP streaming reader.  
 <a href="classtrpc_1_1stream_1_1_http_async_stream_reader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stream__reader__writer_8h_source.html">stream_reader_writer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for trpc::stream::HttpAsyncStreamReader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtrpc_1_1stream_1_1_http_async_stream_reader.png" usemap="#trpc::stream::HttpAsyncStreamReader_map" alt=""/>
  <map id="trpc::stream::HttpAsyncStreamReader_map" name="trpc::stream::HttpAsyncStreamReader_map">
<area href="classtrpc_1_1_ref_counted.html" alt="trpc::RefCounted&lt; HttpAsyncStreamReader &gt;" shape="rect" coords="139,0,407,24"/>
<area href="classtrpc_1_1stream_1_1_http_client_async_stream_reader.html" title="Asynchronous HTTP client streaming reader." alt="trpc::stream::HttpClientAsyncStreamReader" shape="rect" coords="0,112,268,136"/>
<area href="classtrpc_1_1stream_1_1_http_server_async_stream_reader.html" title="Asynchronous HTTP server streaming reader." alt="trpc::stream::HttpServerAsyncStreamReader" shape="rect" coords="278,112,546,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0efb3093d80b8cdb21834da9f81b5bc" id="r_af0efb3093d80b8cdb21834da9f81b5bc"><td class="memItemLeft" align="right" valign="top"><a id="af0efb3093d80b8cdb21834da9f81b5bc" name="af0efb3093d80b8cdb21834da9f81b5bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HttpAsyncStreamReader</b> (HttpAsyncStreamPtr stream)</td></tr>
<tr class="separator:af0efb3093d80b8cdb21834da9f81b5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5b1ba4d4f8e742192924f82083cd2c" id="r_a1b5b1ba4d4f8e742192924f82083cd2c"><td class="memItemLeft" align="right" valign="top">Future&lt; http::HttpHeader &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader.html#a1b5b1ba4d4f8e742192924f82083cd2c">ReadHeader</a> (int timeout=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr class="memdesc:a1b5b1ba4d4f8e742192924f82083cd2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads Header.  <br /></td></tr>
<tr class="separator:a1b5b1ba4d4f8e742192924f82083cd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6f9155ca1a20220cf80a66ff566270" id="r_abf6f9155ca1a20220cf80a66ff566270"><td class="memItemLeft" align="right" valign="top">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader.html#abf6f9155ca1a20220cf80a66ff566270">ReadChunk</a> (int timeout=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr class="memdesc:abf6f9155ca1a20220cf80a66ff566270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a chunk in chunked mode, note that reading in non-chunked mode will fail.  <br /></td></tr>
<tr class="separator:abf6f9155ca1a20220cf80a66ff566270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9606bfd90a2d051f93aa3047acd060f1" id="r_a9606bfd90a2d051f93aa3047acd060f1"><td class="memItemLeft" align="right" valign="top">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader.html#a9606bfd90a2d051f93aa3047acd060f1">ReadAtMost</a> (uint64_t len, int timeout=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr class="memdesc:a9606bfd90a2d051f93aa3047acd060f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads at most len data.  <br /></td></tr>
<tr class="separator:a9606bfd90a2d051f93aa3047acd060f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31871276108407d7af312983912e74f9" id="r_a31871276108407d7af312983912e74f9"><td class="memItemLeft" align="right" valign="top">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader.html#a31871276108407d7af312983912e74f9">ReadExactly</a> (uint64_t len, int timeout=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr class="memdesc:a31871276108407d7af312983912e74f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data with a fixed length.  <br /></td></tr>
<tr class="separator:a31871276108407d7af312983912e74f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtrpc_1_1_ref_counted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtrpc_1_1_ref_counted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtrpc_1_1_ref_counted.html">trpc::RefCounted&lt; HttpAsyncStreamReader &gt;</a></td></tr>
<tr class="memitem:a80c01def90817ae47c84116eed876a14 inherit pub_methods_classtrpc_1_1_ref_counted" id="r_a80c01def90817ae47c84116eed876a14"><td class="memItemLeft" align="right" valign="top">
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>Ref</b> () noexcept</td></tr>
<tr class="separator:a80c01def90817ae47c84116eed876a14 inherit pub_methods_classtrpc_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff6db6d54b9cad9073cf07cdf07d4dc inherit pub_methods_classtrpc_1_1_ref_counted" id="r_a3ff6db6d54b9cad9073cf07cdf07d4dc"><td class="memItemLeft" align="right" valign="top">
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>Deref</b> () noexcept</td></tr>
<tr class="separator:a3ff6db6d54b9cad9073cf07cdf07d4dc inherit pub_methods_classtrpc_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d739e8034fb35ffbab9dff6932dd28 inherit pub_methods_classtrpc_1_1_ref_counted" id="r_a81d739e8034fb35ffbab9dff6932dd28"><td class="memItemLeft" align="right" valign="top">
constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>UnsafeRefCount</b> () const noexcept</td></tr>
<tr class="separator:a81d739e8034fb35ffbab9dff6932dd28 inherit pub_methods_classtrpc_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Asynchronous HTTP streaming reader. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9606bfd90a2d051f93aa3047acd060f1" name="a9606bfd90a2d051f93aa3047acd060f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9606bfd90a2d051f93aa3047acd060f1">&#9670;&#160;</a></span>ReadAtMost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt; trpc::stream::HttpAsyncStreamReader::ReadAtMost </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::numeric_limits&lt;&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads at most len data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>max size to read </td></tr>
    <tr><td class="paramname">timeout</td><td>time to wait for the header to be ready </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the size of the data obtained from the network is smaller than len, it will return size length data. If the size of the data obtained from the network is greater than len, it will return len length data. An empty buffer means that the end has been read Usage scenario 1: Limits the maximum length of each read When the memory is limited. Usage scenario 2: Gets part of data in time and send it downstream on route server. </dd></dl>

</div>
</div>
<a id="abf6f9155ca1a20220cf80a66ff566270" name="abf6f9155ca1a20220cf80a66ff566270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6f9155ca1a20220cf80a66ff566270">&#9670;&#160;</a></span>ReadChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt; trpc::stream::HttpAsyncStreamReader::ReadChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::numeric_limits&lt;&#160;int&#160;&gt;::max()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a chunk in chunked mode, note that reading in non-chunked mode will fail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>time to wait for the header to be ready </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31871276108407d7af312983912e74f9" name="a31871276108407d7af312983912e74f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31871276108407d7af312983912e74f9">&#9670;&#160;</a></span>ReadExactly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt; trpc::stream::HttpAsyncStreamReader::ReadExactly </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::numeric_limits&lt;&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data with a fixed length. </p>
<p>If eof is read, it will return as much data as there is in the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>size to read </td></tr>
    <tr><td class="paramname">timeout</td><td>time to wait for the header to be ready </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the read buffer size is less than the required length, it means that eof has been read. Usage scenario 1: The requested data is compressed by a fixed size, and needs to be read and decompressed by a fixed size. </dd></dl>

</div>
</div>
<a id="a1b5b1ba4d4f8e742192924f82083cd2c" name="a1b5b1ba4d4f8e742192924f82083cd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5b1ba4d4f8e742192924f82083cd2c">&#9670;&#160;</a></span>ReadHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; http::HttpHeader &gt; trpc::stream::HttpAsyncStreamReader::ReadHeader </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::numeric_limits&lt;&#160;int&#160;&gt;::max()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads Header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>time to wait for the header to be ready </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>trpc/stream/http/async/<a class="el" href="stream__reader__writer_8h_source.html">stream_reader_writer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 10 2023 16:03:03 for tRPC-Cpp by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
