<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tRPC-Cpp: trpc::stream::StreamReaderWriter&lt; W, R &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tRPC-Cpp<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetrpc.html">trpc</a></li><li class="navelem"><a class="el" href="namespacetrpc_1_1stream.html">stream</a></li><li class="navelem"><a class="el" href="classtrpc_1_1stream_1_1_stream_reader_writer.html">StreamReaderWriter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">trpc::stream::StreamReaderWriter&lt; W, R &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The synchronous stream reader/writer.  
 <a href="classtrpc_1_1stream_1_1_stream_reader_writer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stream_8h_source.html">stream.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a54a1cb4f63be4033035c56179384feaf" id="r_a54a1cb4f63be4033035c56179384feaf"><td class="memItemLeft" align="right" valign="top"><a id="a54a1cb4f63be4033035c56179384feaf" name="a54a1cb4f63be4033035c56179384feaf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>StreamReaderWriter</b> (const StreamReaderImplPtr&lt; R &gt; &amp;reader, const StreamWriterImplPtr&lt; W &gt; &amp;writer)</td></tr>
<tr class="separator:a54a1cb4f63be4033035c56179384feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ca223a68fd169edff0a6a90cedd838" id="r_a30ca223a68fd169edff0a6a90cedd838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_stream_reader_writer.html#a30ca223a68fd169edff0a6a90cedd838">Read</a> (R *msg, int timeout=-1) const</td></tr>
<tr class="memdesc:a30ca223a68fd169edff0a6a90cedd838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a message from the stream with optional timeout, the order in which messages are read is consistent with the order in which they were sent by the remote peer.  <br /></td></tr>
<tr class="separator:a30ca223a68fd169edff0a6a90cedd838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0097348994bacd904b72023d4417ba9" id="r_ac0097348994bacd904b72023d4417ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_stream_reader_writer.html#ac0097348994bacd904b72023d4417ba9">Write</a> (const W &amp;msg) const</td></tr>
<tr class="memdesc:ac0097348994bacd904b72023d4417ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message to the stream.  <br /></td></tr>
<tr class="separator:ac0097348994bacd904b72023d4417ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd012163070d1bc4752eea848b9e319" id="r_afbd012163070d1bc4752eea848b9e319"><td class="memItemLeft" align="right" valign="top"><a id="afbd012163070d1bc4752eea848b9e319" name="afbd012163070d1bc4752eea848b9e319"></a>
<a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WriteDone</b> () const</td></tr>
<tr class="memdesc:afbd012163070d1bc4752eea848b9e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">It indicates all messages were written. It will send EOF message to the remote peer. <br /></td></tr>
<tr class="separator:afbd012163070d1bc4752eea848b9e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af029c055cce00144c8831c1b8cf85c21" id="r_af029c055cce00144c8831c1b8cf85c21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_stream_reader_writer.html#af029c055cce00144c8831c1b8cf85c21">Finish</a> () const</td></tr>
<tr class="memdesc:af029c055cce00144c8831c1b8cf85c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes the stream.  <br /></td></tr>
<tr class="separator:af029c055cce00144c8831c1b8cf85c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6021c72cc844e6a07104ee3fc9a4c4" id="r_a2f6021c72cc844e6a07104ee3fc9a4c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_stream_reader_writer.html#a2f6021c72cc844e6a07104ee3fc9a4c4">GetStatus</a> () const</td></tr>
<tr class="memdesc:a2f6021c72cc844e6a07104ee3fc9a4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inner status of stream.  <br /></td></tr>
<tr class="separator:a2f6021c72cc844e6a07104ee3fc9a4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86b56d29df8df947384dde5157d6910" id="r_ad86b56d29df8df947384dde5157d6910"><td class="memItemLeft" align="right" valign="top"><a id="ad86b56d29df8df947384dde5157d6910" name="ad86b56d29df8df947384dde5157d6910"></a>
<a class="el" href="classtrpc_1_1stream_1_1_stream_reader.html">StreamReader</a>&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Reader</b> () const</td></tr>
<tr class="memdesc:ad86b56d29df8df947384dde5157d6910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal stream reader which provides a limited interfaces. <br /></td></tr>
<tr class="separator:ad86b56d29df8df947384dde5157d6910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaab6b0328c80f64db08a29b90793a16" id="r_adaab6b0328c80f64db08a29b90793a16"><td class="memItemLeft" align="right" valign="top"><a id="adaab6b0328c80f64db08a29b90793a16" name="adaab6b0328c80f64db08a29b90793a16"></a>
<a class="el" href="classtrpc_1_1stream_1_1_stream_writer.html">StreamWriter</a>&lt; W &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Writer</b> () const</td></tr>
<tr class="memdesc:adaab6b0328c80f64db08a29b90793a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal stream writer which provides a limited interfaces. <br /></td></tr>
<tr class="separator:adaab6b0328c80f64db08a29b90793a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename W, typename R&gt;<br />
class trpc::stream::StreamReaderWriter&lt; W, R &gt;</div><p>The synchronous stream reader/writer. </p>
<p>It provides users with streaming programing.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">W</td><td>is the type of message to be written. </td></tr>
    <tr><td class="paramname">R</td><td>is the type of message to be read. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af029c055cce00144c8831c1b8cf85c21" name="af029c055cce00144c8831c1b8cf85c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af029c055cce00144c8831c1b8cf85c21">&#9670;&#160;</a></span>Finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename W , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_status.html">Status</a> <a class="el" href="classtrpc_1_1stream_1_1_stream_reader_writer.html">trpc::stream::StreamReaderWriter</a>&lt; W, R &gt;::Finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes the stream. </p>
<p>For the client, an EOF will be sent to the server automatically, and the final RPC execution result will be waited. For the server, nothing happens. It's recommended to call this method on the client side, but it is optional for the server side, because the stream will be closed automatically when user's function of service returned. It makes no difference in the final result whether it's called from the "StreamReader", "StreamWriter" or "StreamReaderWriter" specified stream. For one stream, it should be called at most once at each side, it is also regarded as a writing operation, hence, it should be called after the previous write or read operation (if any) to complete, otherwise it's undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the final RPC execution result. </dd></dl>

</div>
</div>
<a id="a2f6021c72cc844e6a07104ee3fc9a4c4" name="a2f6021c72cc844e6a07104ee3fc9a4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6021c72cc844e6a07104ee3fc9a4c4">&#9670;&#160;</a></span>GetStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename W , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_status.html">Status</a> <a class="el" href="classtrpc_1_1stream_1_1_stream_reader_writer.html">trpc::stream::StreamReaderWriter</a>&lt; W, R &gt;::GetStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inner status of stream. </p>
<p>If you want to known the details of error occurred in the stream, it will help. </p>

</div>
</div>
<a id="a30ca223a68fd169edff0a6a90cedd838" name="a30ca223a68fd169edff0a6a90cedd838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ca223a68fd169edff0a6a90cedd838">&#9670;&#160;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename W , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_status.html">Status</a> <a class="el" href="classtrpc_1_1stream_1_1_stream_reader_writer.html">trpc::stream::StreamReaderWriter</a>&lt; W, R &gt;::Read </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a message from the stream with optional timeout, the order in which messages are read is consistent with the order in which they were sent by the remote peer. </p>
<p>A reading should starts before the previous reading (if any) to complete, i.e. at most one reading operation can be performed at the same time, otherwise it's undefined behavior. A stream is a full-duplex communication channel, hence reading and writing can be performed concurrently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>is a pointer to the streaming message, which will be updated to the message read successfully from the stream. </td></tr>
    <tr><td class="paramname">timeout</td><td>is the timeout for waiting, the function will block until a message is ready<ul>
<li>-1: wait indefinitely, &gt;=0: wait for timeout in milliseconds.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns status of the reading operation. An ok status will be returned if good message was read successfully. If EOF is read, it indicates the end of the stream. If a timeout is reached, it means that the remote peer did not send any more messages within the timeout period. There may be other errors than occur, such as network errors. </dd></dl>

</div>
</div>
<a id="ac0097348994bacd904b72023d4417ba9" name="ac0097348994bacd904b72023d4417ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0097348994bacd904b72023d4417ba9">&#9670;&#160;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename W , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_status.html">Status</a> <a class="el" href="classtrpc_1_1stream_1_1_stream_reader_writer.html">trpc::stream::StreamReaderWriter</a>&lt; W, R &gt;::Write </td>
          <td>(</td>
          <td class="paramtype">const W &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a message to the stream. </p>
<p>A writing operation should start before the previous writing (if any) to complete, i.e. at most one reading operation can be performed at the same time, otherwise it's undefined behavior. A stream is a full-duplex communication channel, hence reading and writing can be performed concurrently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>is a message to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a status of writing operation. An ok status will be returned if no error occurred, but it does NOT mean the message has already bee sent on the wire. Error status Otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>trpc/stream/<a class="el" href="stream_8h_source.html">stream.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 10 2023 16:03:03 for tRPC-Cpp by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
