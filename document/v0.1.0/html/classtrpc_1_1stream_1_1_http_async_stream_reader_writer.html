<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tRPC-Cpp: trpc::stream::HttpAsyncStreamReaderWriter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tRPC-Cpp<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetrpc.html">trpc</a></li><li class="navelem"><a class="el" href="namespacetrpc_1_1stream.html">stream</a></li><li class="navelem"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader_writer.html">HttpAsyncStreamReaderWriter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle"><div class="title">trpc::stream::HttpAsyncStreamReaderWriter Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Asynchronous HTTP streaming reader-writer.  
 <a href="classtrpc_1_1stream_1_1_http_async_stream_reader_writer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stream__reader__writer_8h_source.html">stream_reader_writer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for trpc::stream::HttpAsyncStreamReaderWriter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtrpc_1_1stream_1_1_http_async_stream_reader_writer.png" usemap="#trpc::stream::HttpAsyncStreamReaderWriter_map" alt=""/>
  <map id="trpc::stream::HttpAsyncStreamReaderWriter_map" name="trpc::stream::HttpAsyncStreamReaderWriter_map">
<area href="classtrpc_1_1_ref_counted.html" alt="trpc::RefCounted&lt; HttpAsyncStreamReaderWriter &gt;" shape="rect" coords="156,0,458,24"/>
<area href="classtrpc_1_1stream_1_1_http_client_async_stream_reader_writer.html" title="Asynchronous client streaming reader-writer." alt="trpc::stream::HttpClientAsyncStreamReaderWriter" shape="rect" coords="0,112,302,136"/>
<area href="classtrpc_1_1stream_1_1_http_server_async_stream_reader_writer.html" title="Asynchronous server streaming reader-writer." alt="trpc::stream::HttpServerAsyncStreamReaderWriter" shape="rect" coords="312,112,614,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38c08060a99dfbff39171224cfdabf08" id="r_a38c08060a99dfbff39171224cfdabf08"><td class="memItemLeft" align="right" valign="top"><a id="a38c08060a99dfbff39171224cfdabf08" name="a38c08060a99dfbff39171224cfdabf08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HttpAsyncStreamReaderWriter</b> (HttpAsyncStreamPtr stream)</td></tr>
<tr class="separator:a38c08060a99dfbff39171224cfdabf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dff2d0f98e4def24ee700e3101093aa" id="r_a0dff2d0f98e4def24ee700e3101093aa"><td class="memItemLeft" align="right" valign="top">Future&lt; http::HttpHeader &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader_writer.html#a0dff2d0f98e4def24ee700e3101093aa">ReadHeader</a> (int timeout=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr class="memdesc:a0dff2d0f98e4def24ee700e3101093aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads Header.  <br /></td></tr>
<tr class="separator:a0dff2d0f98e4def24ee700e3101093aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbc996ea0b81903f5c5b8cc136b0c8c" id="r_a3bbc996ea0b81903f5c5b8cc136b0c8c"><td class="memItemLeft" align="right" valign="top">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader_writer.html#a3bbc996ea0b81903f5c5b8cc136b0c8c">ReadChunk</a> (int timeout=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr class="memdesc:a3bbc996ea0b81903f5c5b8cc136b0c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a chunk in chunked mode, note that reading in non-chunked mode will fail.  <br /></td></tr>
<tr class="separator:a3bbc996ea0b81903f5c5b8cc136b0c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a89ab89fa10cd611387da99f757bb36" id="r_a3a89ab89fa10cd611387da99f757bb36"><td class="memItemLeft" align="right" valign="top">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader_writer.html#a3a89ab89fa10cd611387da99f757bb36">ReadAtMost</a> (uint64_t len, int timeout=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr class="memdesc:a3a89ab89fa10cd611387da99f757bb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads at most len data.  <br /></td></tr>
<tr class="separator:a3a89ab89fa10cd611387da99f757bb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f7daf231936408696896c46c126479" id="r_a12f7daf231936408696896c46c126479"><td class="memItemLeft" align="right" valign="top">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader_writer.html#a12f7daf231936408696896c46c126479">ReadExactly</a> (uint64_t len, int timeout=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr class="memdesc:a12f7daf231936408696896c46c126479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data with a fixed length.  <br /></td></tr>
<tr class="separator:a12f7daf231936408696896c46c126479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3057110c0b062654f19baeb6cf628f45" id="r_a3057110c0b062654f19baeb6cf628f45"><td class="memItemLeft" align="right" valign="top"><a id="a3057110c0b062654f19baeb6cf628f45" name="a3057110c0b062654f19baeb6cf628f45"></a>
Future&#160;</td><td class="memItemRight" valign="bottom"><b>WriteHeader</b> (http::HttpHeader &amp;&amp;header)</td></tr>
<tr class="memdesc:a3057110c0b062654f19baeb6cf628f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes header or trailer. <br /></td></tr>
<tr class="separator:a3057110c0b062654f19baeb6cf628f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f511b5bf4013d0d7d3fd9bbdd26bd6e" id="r_a8f511b5bf4013d0d7d3fd9bbdd26bd6e"><td class="memItemLeft" align="right" valign="top">Future&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader_writer.html#a8f511b5bf4013d0d7d3fd9bbdd26bd6e">WriteData</a> (<a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &amp;&amp;data)</td></tr>
<tr class="memdesc:a8f511b5bf4013d0d7d3fd9bbdd26bd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data.  <br /></td></tr>
<tr class="separator:a8f511b5bf4013d0d7d3fd9bbdd26bd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4567b831d722fc15302dfc122cc4a310" id="r_a4567b831d722fc15302dfc122cc4a310"><td class="memItemLeft" align="right" valign="top"><a id="a4567b831d722fc15302dfc122cc4a310" name="a4567b831d722fc15302dfc122cc4a310"></a>
Future&#160;</td><td class="memItemRight" valign="bottom"><b>WriteDone</b> ()</td></tr>
<tr class="memdesc:a4567b831d722fc15302dfc122cc4a310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies that the data has been written completely. <br /></td></tr>
<tr class="separator:a4567b831d722fc15302dfc122cc4a310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtrpc_1_1_ref_counted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtrpc_1_1_ref_counted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtrpc_1_1_ref_counted.html">trpc::RefCounted&lt; HttpAsyncStreamReaderWriter &gt;</a></td></tr>
<tr class="memitem:a80c01def90817ae47c84116eed876a14 inherit pub_methods_classtrpc_1_1_ref_counted" id="r_a80c01def90817ae47c84116eed876a14"><td class="memItemLeft" align="right" valign="top">
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>Ref</b> () noexcept</td></tr>
<tr class="separator:a80c01def90817ae47c84116eed876a14 inherit pub_methods_classtrpc_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff6db6d54b9cad9073cf07cdf07d4dc inherit pub_methods_classtrpc_1_1_ref_counted" id="r_a3ff6db6d54b9cad9073cf07cdf07d4dc"><td class="memItemLeft" align="right" valign="top">
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>Deref</b> () noexcept</td></tr>
<tr class="separator:a3ff6db6d54b9cad9073cf07cdf07d4dc inherit pub_methods_classtrpc_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d739e8034fb35ffbab9dff6932dd28 inherit pub_methods_classtrpc_1_1_ref_counted" id="r_a81d739e8034fb35ffbab9dff6932dd28"><td class="memItemLeft" align="right" valign="top">
constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>UnsafeRefCount</b> () const noexcept</td></tr>
<tr class="separator:a81d739e8034fb35ffbab9dff6932dd28 inherit pub_methods_classtrpc_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a06e2af11fbbde6ba1758a0fd7cf8e5f8" id="r_a06e2af11fbbde6ba1758a0fd7cf8e5f8"><td class="memItemLeft" align="right" valign="top"><a id="a06e2af11fbbde6ba1758a0fd7cf8e5f8" name="a06e2af11fbbde6ba1758a0fd7cf8e5f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetReaderWriter</b> (<a class="el" href="classtrpc_1_1_ref_ptr.html">HttpAsyncStreamReaderPtr</a> reader, <a class="el" href="classtrpc_1_1_ref_ptr.html">HttpAsyncStreamWriterPtr</a> writer)</td></tr>
<tr class="memdesc:a06e2af11fbbde6ba1758a0fd7cf8e5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reader and writer. <br /></td></tr>
<tr class="separator:a06e2af11fbbde6ba1758a0fd7cf8e5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Asynchronous HTTP streaming reader-writer. </p>
<p>It uses <a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_reader.html" title="Asynchronous HTTP streaming reader.">HttpAsyncStreamReader</a> and <a class="el" href="classtrpc_1_1stream_1_1_http_async_stream_writer.html" title="Asynchronous HTTP streaming writer.">HttpAsyncStreamWriter</a> internally to perform the actual logic. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a89ab89fa10cd611387da99f757bb36" name="a3a89ab89fa10cd611387da99f757bb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a89ab89fa10cd611387da99f757bb36">&#9670;&#160;</a></span>ReadAtMost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt; trpc::stream::HttpAsyncStreamReaderWriter::ReadAtMost </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::numeric_limits&lt;&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads at most len data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>max size to read </td></tr>
    <tr><td class="paramname">timeout</td><td>time to wait for the header to be ready </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the size of the data obtained from the network is smaller than len, it will return size length data. If the size of the data obtained from the network is greater than len, it will return len length data. An empty buffer means that the end has been read Usage scenario 1: Limits the maximum length of each read When the memory is limited. Usage scenario 2: Gets part of data in time and send it downstream on route server. </dd></dl>

</div>
</div>
<a id="a3bbc996ea0b81903f5c5b8cc136b0c8c" name="a3bbc996ea0b81903f5c5b8cc136b0c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbc996ea0b81903f5c5b8cc136b0c8c">&#9670;&#160;</a></span>ReadChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt; trpc::stream::HttpAsyncStreamReaderWriter::ReadChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::numeric_limits&lt;&#160;int&#160;&gt;::max()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a chunk in chunked mode, note that reading in non-chunked mode will fail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>time to wait for the header to be ready </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12f7daf231936408696896c46c126479" name="a12f7daf231936408696896c46c126479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f7daf231936408696896c46c126479">&#9670;&#160;</a></span>ReadExactly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; <a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &gt; trpc::stream::HttpAsyncStreamReaderWriter::ReadExactly </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::numeric_limits&lt;&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data with a fixed length. </p>
<p>If eof is read, it will return as much data as there is in the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>size to read </td></tr>
    <tr><td class="paramname">timeout</td><td>time to wait for the header to be ready </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the read buffer size is less than the required length, it means that eof has been read. Usage scenario 1: The requested data is compressed by a fixed size, and needs to be read and decompressed by a fixed size. </dd></dl>

</div>
</div>
<a id="a0dff2d0f98e4def24ee700e3101093aa" name="a0dff2d0f98e4def24ee700e3101093aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dff2d0f98e4def24ee700e3101093aa">&#9670;&#160;</a></span>ReadHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; http::HttpHeader &gt; trpc::stream::HttpAsyncStreamReaderWriter::ReadHeader </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::numeric_limits&lt;&#160;int&#160;&gt;::max()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads Header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>time to wait for the header to be ready </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f511b5bf4013d0d7d3fd9bbdd26bd6e" name="a8f511b5bf4013d0d7d3fd9bbdd26bd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f511b5bf4013d0d7d3fd9bbdd26bd6e">&#9670;&#160;</a></span>WriteData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Future trpc::stream::HttpAsyncStreamReaderWriter::WriteData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtrpc_1_1_noncontiguous_buffer.html">NoncontiguousBuffer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data. </p>
<dl class="section note"><dt>Note</dt><dd>Writing empty data is not allowed. In chunked mode, empty data represents the end of the chunked data, so WriteDone should be explicitly called to send it. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>trpc/stream/http/async/<a class="el" href="stream__reader__writer_8h_source.html">stream_reader_writer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 10 2023 16:03:03 for tRPC-Cpp by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
