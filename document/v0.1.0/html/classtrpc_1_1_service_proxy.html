<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tRPC-Cpp: trpc::ServiceProxy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tRPC-Cpp<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetrpc.html">trpc</a></li><li class="navelem"><a class="el" href="classtrpc_1_1_service_proxy.html">ServiceProxy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">trpc::ServiceProxy Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class of service proxy.  
 <a href="classtrpc_1_1_service_proxy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="service__proxy_8h_source.html">service_proxy.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for trpc::ServiceProxy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtrpc_1_1_service_proxy.png" usemap="#trpc::ServiceProxy_map" alt=""/>
  <map id="trpc::ServiceProxy_map" name="trpc::ServiceProxy_map">
<area href="classtrpc_1_1_non_rpc_service_proxy.html" title="Non-rpc service proxy." alt="trpc::NonRpcServiceProxy" shape="rect" coords="0,56,182,80"/>
<area href="classtrpc_1_1_rpc_service_proxy.html" title="Rpc service proxy." alt="trpc::RpcServiceProxy" shape="rect" coords="192,56,374,80"/>
<area href="classtrpc_1_1redis_1_1_redis_service_proxy.html" title="Redis client proxy instance, supporting Redis Command such as set, get, mset, mget." alt="trpc::redis::RedisServiceProxy" shape="rect" coords="384,56,566,80"/>
<area href="classtrpc_1_1stream_1_1_http_stream_proxy.html" title="HTTP streaming proxy." alt="trpc::stream::HttpStreamProxy" shape="rect" coords="576,56,758,80"/>
<area href="classtrpc_1_1http_1_1_http_service_proxy.html" title="HTTP client proxy instance, supporting HTTP methods such as GET, HEAD, POST, PUT, DELETE,..." alt="trpc::http::HttpServiceProxy" shape="rect" coords="192,112,374,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6fbcdb6734b1a986c9488cefecf3dff3" id="r_a6fbcdb6734b1a986c9488cefecf3dff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_service_proxy.html#a6fbcdb6734b1a986c9488cefecf3dff3">UnaryInvoke</a> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;context, const ProtocolPtr &amp;req, ProtocolPtr &amp;rsp)</td></tr>
<tr class="memdesc:a6fbcdb6734b1a986c9488cefecf3dff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous call interface oriented to transport (thread-safe).  <br /></td></tr>
<tr class="separator:a6fbcdb6734b1a986c9488cefecf3dff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0deeefc37c18a7f7c4ee6e36338626" id="r_a3e0deeefc37c18a7f7c4ee6e36338626"><td class="memItemLeft" align="right" valign="top">Future&lt; ProtocolPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_service_proxy.html#a3e0deeefc37c18a7f7c4ee6e36338626">AsyncUnaryInvoke</a> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;context, const ProtocolPtr &amp;req)</td></tr>
<tr class="memdesc:a3e0deeefc37c18a7f7c4ee6e36338626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous call interface oriented to transport (thread-safe).  <br /></td></tr>
<tr class="separator:a3e0deeefc37c18a7f7c4ee6e36338626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056ea7c0c0d3ed593788835184f5f148" id="r_a056ea7c0c0d3ed593788835184f5f148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_service_proxy.html#a056ea7c0c0d3ed593788835184f5f148">OnewayInvoke</a> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;context, const ProtocolPtr &amp;req)</td></tr>
<tr class="memdesc:a056ea7c0c0d3ed593788835184f5f148"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-way call interface oriented to transport (thread-safe).  <br /></td></tr>
<tr class="separator:a056ea7c0c0d3ed593788835184f5f148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b39658951b9960e5c636d91b33def69" id="r_a5b39658951b9960e5c636d91b33def69"><td class="memItemLeft" align="right" valign="top"><a id="a5b39658951b9960e5c636d91b33def69" name="a5b39658951b9960e5c636d91b33def69"></a>
const <a class="el" href="structtrpc_1_1_service_proxy_option.html">ServiceProxyOption</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetServiceProxyOption</b> ()</td></tr>
<tr class="memdesc:a5b39658951b9960e5c636d91b33def69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get option of service proxy (thread-safe). <br /></td></tr>
<tr class="separator:a5b39658951b9960e5c636d91b33def69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404feeed8e435bd7efd933869880f081" id="r_a404feeed8e435bd7efd933869880f081"><td class="memItemLeft" align="right" valign="top"><a id="a404feeed8e435bd7efd933869880f081" name="a404feeed8e435bd7efd933869880f081"></a>
<a class="el" href="structtrpc_1_1_service_proxy_option.html">ServiceProxyOption</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMutableServiceProxyOption</b> ()</td></tr>
<tr class="separator:a404feeed8e435bd7efd933869880f081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81040959a021312ce144d35c651982c" id="r_af81040959a021312ce144d35c651982c"><td class="memItemLeft" align="right" valign="top"><a id="af81040959a021312ce144d35c651982c" name="af81040959a021312ce144d35c651982c"></a>
const ClientCodecPtr &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetClientCodec</b> ()</td></tr>
<tr class="memdesc:af81040959a021312ce144d35c651982c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get codec used by service proxy (thread-safe). <br /></td></tr>
<tr class="separator:af81040959a021312ce144d35c651982c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c0b3822eaf59bc635a597f77d7e769" id="r_a43c0b3822eaf59bc635a597f77d7e769"><td class="memItemLeft" align="right" valign="top"><a id="a43c0b3822eaf59bc635a597f77d7e769" name="a43c0b3822eaf59bc635a597f77d7e769"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Stop</b> ()</td></tr>
<tr class="memdesc:a43c0b3822eaf59bc635a597f77d7e769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop used resources by service proxy (thread-safe). <br /></td></tr>
<tr class="separator:a43c0b3822eaf59bc635a597f77d7e769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e04a2154546a30f00a2d145410791b4" id="r_a5e04a2154546a30f00a2d145410791b4"><td class="memItemLeft" align="right" valign="top"><a id="a5e04a2154546a30f00a2d145410791b4" name="a5e04a2154546a30f00a2d145410791b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Destroy</b> ()</td></tr>
<tr class="memdesc:a5e04a2154546a30f00a2d145410791b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy used resources by service proxy (thread-safe). <br /></td></tr>
<tr class="separator:a5e04a2154546a30f00a2d145410791b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117e4821c4b4f78b8b252f7af4c98258" id="r_a117e4821c4b4f78b8b252f7af4c98258"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_service_proxy.html#a117e4821c4b4f78b8b252f7af4c98258">GetOrCreateConnector</a> (const <a class="el" href="structtrpc_1_1_preallocation_option.html">PreallocationOption</a> &amp;preallocate_option)</td></tr>
<tr class="memdesc:a117e4821c4b4f78b8b252f7af4c98258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-allocate a connection, used for scenarios that require fixed connections for data transmission (thread-safe).  <br /></td></tr>
<tr class="separator:a117e4821c4b4f78b8b252f7af4c98258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002074371db6c6a51dbd6a196b842b7" id="r_a6002074371db6c6a51dbd6a196b842b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_service_proxy.html#a6002074371db6c6a51dbd6a196b842b7">ReleaseFixedConnector</a> (uint64_t connector_id)</td></tr>
<tr class="memdesc:a6002074371db6c6a51dbd6a196b842b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a fixed connection (not thread-safe).  <br /></td></tr>
<tr class="separator:a6002074371db6c6a51dbd6a196b842b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5fd17509f51c51dec76fc25685b74a" id="r_a1d5fd17509f51c51dec76fc25685b74a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_service_proxy.html#a1d5fd17509f51c51dec76fc25685b74a">Disconnect</a> (const std::string &amp;target_ip)</td></tr>
<tr class="memdesc:a1d5fd17509f51c51dec76fc25685b74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate disconnection from all connections with a specified IP node.  <br /></td></tr>
<tr class="separator:a1d5fd17509f51c51dec76fc25685b74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a78ad87186b1b9d7501a7f46e1a81aa42" id="r_a78ad87186b1b9d7501a7f46e1a81aa42"><td class="memItemLeft" align="right" valign="top"><a id="a78ad87186b1b9d7501a7f46e1a81aa42" name="a78ad87186b1b9d7501a7f46e1a81aa42"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>UnaryTransportInvoke</b> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;context, const ProtocolPtr &amp;req, ProtocolPtr &amp;rsp)</td></tr>
<tr class="memdesc:a78ad87186b1b9d7501a7f46e1a81aa42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous call interface oriented to transport, it will be call by UnaryInvoke. <br /></td></tr>
<tr class="separator:a78ad87186b1b9d7501a7f46e1a81aa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37600f4bf0ec213a7f1a8baa75886f98" id="r_a37600f4bf0ec213a7f1a8baa75886f98"><td class="memItemLeft" align="right" valign="top"><a id="a37600f4bf0ec213a7f1a8baa75886f98" name="a37600f4bf0ec213a7f1a8baa75886f98"></a>
virtual Future&lt; ProtocolPtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AsyncUnaryTransportInvoke</b> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;context, const ProtocolPtr &amp;req_protocol)</td></tr>
<tr class="memdesc:a37600f4bf0ec213a7f1a8baa75886f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous call interface oriented to transport, it will be call by AsyncUnaryInvoke. <br /></td></tr>
<tr class="separator:a37600f4bf0ec213a7f1a8baa75886f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1101bb7bbc4f640dfd13e2b9b2a99e6b" id="r_a1101bb7bbc4f640dfd13e2b9b2a99e6b"><td class="memItemLeft" align="right" valign="top"><a id="a1101bb7bbc4f640dfd13e2b9b2a99e6b" name="a1101bb7bbc4f640dfd13e2b9b2a99e6b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>OnewayTransportInvoke</b> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;context, const ProtocolPtr &amp;req)</td></tr>
<tr class="memdesc:a1101bb7bbc4f640dfd13e2b9b2a99e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-way call interface oriented to transport, it will be call by OnewayInvoke. <br /></td></tr>
<tr class="separator:a1101bb7bbc4f640dfd13e2b9b2a99e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4a2bfd2f82ece37585cc3305fec426" id="r_a9b4a2bfd2f82ece37585cc3305fec426"><td class="memItemLeft" align="right" valign="top"><a id="a9b4a2bfd2f82ece37585cc3305fec426" name="a9b4a2bfd2f82ece37585cc3305fec426"></a>
virtual stream::StreamReaderWriterProviderPtr&#160;</td><td class="memItemRight" valign="bottom"><b>SelectStreamProvider</b> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;context, void *rpc_reply_msg=nullptr)</td></tr>
<tr class="memdesc:a9b4a2bfd2f82ece37585cc3305fec426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create StreamReaderWriterProvider. <br /></td></tr>
<tr class="separator:a9b4a2bfd2f82ece37585cc3305fec426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee51930a534bca268e9cca1f484fd7e" id="r_aeee51930a534bca268e9cca1f484fd7e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_service_proxy.html#aeee51930a534bca268e9cca1f484fd7e">NeedSelector</a> ()</td></tr>
<tr class="memdesc:aeee51930a534bca268e9cca1f484fd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a selector plugin is required for the proxy.  <br /></td></tr>
<tr class="separator:aeee51930a534bca268e9cca1f484fd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcc9a8011cf12b37648f8e34092b638" id="r_a5fcc9a8011cf12b37648f8e34092b638"><td class="memItemLeft" align="right" valign="top"><a id="a5fcc9a8011cf12b37648f8e34092b638" name="a5fcc9a8011cf12b37648f8e34092b638"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetServiceProxyOptionInner</b> (const std::shared_ptr&lt; <a class="el" href="structtrpc_1_1_service_proxy_option.html">ServiceProxyOption</a> &gt; &amp;option)</td></tr>
<tr class="memdesc:a5fcc9a8011cf12b37648f8e34092b638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the options of service proxy, which can be overridden by the subclass to customize the settings. <br /></td></tr>
<tr class="separator:a5fcc9a8011cf12b37648f8e34092b638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5320beb90aa8e940d37cdcfd96f18b2" id="r_ab5320beb90aa8e940d37cdcfd96f18b2"><td class="memItemLeft" align="right" valign="top"><a id="ab5320beb90aa8e940d37cdcfd96f18b2" name="ab5320beb90aa8e940d37cdcfd96f18b2"></a>
virtual TransInfo&#160;</td><td class="memItemRight" valign="bottom"><b>ProxyOptionToTransInfo</b> ()</td></tr>
<tr class="memdesc:ab5320beb90aa8e940d37cdcfd96f18b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to obtain transinfo based on options, which can be overridden by the subclass to customize the trans_info. <br /></td></tr>
<tr class="separator:ab5320beb90aa8e940d37cdcfd96f18b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ec5a2ac33e50e13ebe842ec3b0fd64" id="r_a15ec5a2ac33e50e13ebe842ec3b0fd64"><td class="memItemLeft" align="right" valign="top"><a id="a15ec5a2ac33e50e13ebe842ec3b0fd64" name="a15ec5a2ac33e50e13ebe842ec3b0fd64"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetServiceName</b> ()</td></tr>
<tr class="memdesc:a15ec5a2ac33e50e13ebe842ec3b0fd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the service routing name, which is the name of service proxy for direct connections, and the target in the options for non-direct connection models. <br /></td></tr>
<tr class="separator:a15ec5a2ac33e50e13ebe842ec3b0fd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996f577b8b21ce9b4b88aa0a6d117512" id="r_a996f577b8b21ce9b4b88aa0a6d117512"><td class="memItemLeft" align="right" valign="top"><a id="a996f577b8b21ce9b4b88aa0a6d117512" name="a996f577b8b21ce9b4b88aa0a6d117512"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FillClientContext</b> (const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;context)</td></tr>
<tr class="memdesc:a996f577b8b21ce9b4b88aa0a6d117512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the proxy option parameters to set the context. <br /></td></tr>
<tr class="separator:a996f577b8b21ce9b4b88aa0a6d117512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd048e6e3527661efb76b5843c682fcd" id="r_afd048e6e3527661efb76b5843c682fcd"><td class="memItemLeft" align="right" valign="top"><a id="afd048e6e3527661efb76b5843c682fcd" name="afd048e6e3527661efb76b5843c682fcd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>RunFilters</b> (const <a class="el" href="namespacetrpc.html#a30ad6719274d32670d65731183e4db12">FilterPoint</a> &amp;point, const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;context)</td></tr>
<tr class="memdesc:afd048e6e3527661efb76b5843c682fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run filters by filter point. <br /></td></tr>
<tr class="separator:afd048e6e3527661efb76b5843c682fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d208aa0b3e3288a374b18306d2fa1ba" id="r_a8d208aa0b3e3288a374b18306d2fa1ba"><td class="memItemLeft" align="right" valign="top"><a id="a8d208aa0b3e3288a374b18306d2fa1ba" name="a8d208aa0b3e3288a374b18306d2fa1ba"></a>
<a class="el" href="classtrpc_1_1_thread_model.html">ThreadModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetThreadModel</b> ()</td></tr>
<tr class="memdesc:a8d208aa0b3e3288a374b18306d2fa1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the threadmodel used by service proxy. <br /></td></tr>
<tr class="separator:a8d208aa0b3e3288a374b18306d2fa1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db9e4b71b0d5eba1097ed56621d002e" id="r_a4db9e4b71b0d5eba1097ed56621d002e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrpc_1_1_service_proxy.html#a4db9e4b71b0d5eba1097ed56621d002e">InitTransport</a> ()</td></tr>
<tr class="memdesc:a4db9e4b71b0d5eba1097ed56621d002e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init transport used by service proxy.  <br /></td></tr>
<tr class="separator:a4db9e4b71b0d5eba1097ed56621d002e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a54c60d19274df2c3bb5a8019d4d8287f" id="r_a54c60d19274df2c3bb5a8019d4d8287f"><td class="memItemLeft" align="right" valign="top"><a id="a54c60d19274df2c3bb5a8019d4d8287f" name="a54c60d19274df2c3bb5a8019d4d8287f"></a>
ClientCodecPtr&#160;</td><td class="memItemRight" valign="bottom"><b>codec_</b></td></tr>
<tr class="separator:a54c60d19274df2c3bb5a8019d4d8287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883a9c979eb26d15774d4b11ce06dd82" id="r_a883a9c979eb26d15774d4b11ce06dd82"><td class="memItemLeft" align="right" valign="top"><a id="a883a9c979eb26d15774d4b11ce06dd82" name="a883a9c979eb26d15774d4b11ce06dd82"></a>
std::unique_ptr&lt; ClientTransport &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>transport_</b> {nullptr}</td></tr>
<tr class="separator:a883a9c979eb26d15774d4b11ce06dd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad4c9944ceea6906ea0d8f20c95457" id="r_a08ad4c9944ceea6906ea0d8f20c95457"><td class="memItemLeft" align="right" valign="top"><a id="a08ad4c9944ceea6906ea0d8f20c95457" name="a08ad4c9944ceea6906ea0d8f20c95457"></a>
ClientFilterController&#160;</td><td class="memItemRight" valign="bottom"><b>filter_controller_</b></td></tr>
<tr class="separator:a08ad4c9944ceea6906ea0d8f20c95457"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af242b524219edb7cf3427796448070b5" id="r_af242b524219edb7cf3427796448070b5"><td class="memItemLeft" align="right" valign="top"><a id="af242b524219edb7cf3427796448070b5" name="af242b524219edb7cf3427796448070b5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ServiceProxyManager</b></td></tr>
<tr class="separator:af242b524219edb7cf3427796448070b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class of service proxy. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3e0deeefc37c18a7f7c4ee6e36338626" name="a3e0deeefc37c18a7f7c4ee6e36338626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0deeefc37c18a7f7c4ee6e36338626">&#9670;&#160;</a></span>AsyncUnaryInvoke()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Future&lt; ProtocolPtr &gt; trpc::ServiceProxy::AsyncUnaryInvoke </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProtocolPtr &amp;&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous call interface oriented to transport (thread-safe). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td><a class="el" href="classtrpc_1_1_protocol.html" title="An interface representing the ability to decode and encode a protocol message.">Protocol</a> object with serialized request body data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ready future with protocol object with body data not yet serialized on success, failed future on failed. </dd></dl>

</div>
</div>
<a id="a1d5fd17509f51c51dec76fc25685b74a" name="a1d5fd17509f51c51dec76fc25685b74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5fd17509f51c51dec76fc25685b74a">&#9670;&#160;</a></span>Disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trpc::ServiceProxy::Disconnect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target_ip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate disconnection from all connections with a specified IP node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_ip</td><td>The IP address of the specified node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Currently, only the IO/Handle separation and merging mode is supported. </dd></dl>

</div>
</div>
<a id="a117e4821c4b4f78b8b252f7af4c98258" name="a117e4821c4b4f78b8b252f7af4c98258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117e4821c4b4f78b8b252f7af4c98258">&#9670;&#160;</a></span>GetOrCreateConnector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; uint64_t &gt; trpc::ServiceProxy::GetOrCreateConnector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrpc_1_1_preallocation_option.html">PreallocationOption</a> &amp;&#160;</td>
          <td class="paramname"><em>preallocate_option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre-allocate a connection, used for scenarios that require fixed connections for data transmission (thread-safe). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">preallocate_option</td><td>Pre-allocated parameters related to backend nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::nullopt on failed, connection identifier on success. </dd></dl>

</div>
</div>
<a id="a4db9e4b71b0d5eba1097ed56621d002e" name="a4db9e4b71b0d5eba1097ed56621d002e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db9e4b71b0d5eba1097ed56621d002e">&#9670;&#160;</a></span>InitTransport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void trpc::ServiceProxy::InitTransport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Init transport used by service proxy. </p>
<p>By default, the framework uses its built-in transport. </p><dl class="section note"><dt>Note</dt><dd>Subclasses can implement transport by overriding this method themselves. </dd></dl>

</div>
</div>
<a id="aeee51930a534bca268e9cca1f484fd7e" name="aeee51930a534bca268e9cca1f484fd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee51930a534bca268e9cca1f484fd7e">&#9670;&#160;</a></span>NeedSelector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool trpc::ServiceProxy::NeedSelector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a selector plugin is required for the proxy. </p>
<dl class="section note"><dt>Note</dt><dd>If a selector is not required for the subclass, it can be overridden to return false. </dd></dl>

</div>
</div>
<a id="a056ea7c0c0d3ed593788835184f5f148" name="a056ea7c0c0d3ed593788835184f5f148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056ea7c0c0d3ed593788835184f5f148">&#9670;&#160;</a></span>OnewayInvoke()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_status.html">Status</a> trpc::ServiceProxy::OnewayInvoke </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProtocolPtr &amp;&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One-way call interface oriented to transport (thread-safe). </p>
<dl class="section return"><dt>Returns</dt><dd>OK status on success, otherwise on failed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It only completes request sending without waiting for response. </dd></dl>

</div>
</div>
<a id="a6002074371db6c6a51dbd6a196b842b7" name="a6002074371db6c6a51dbd6a196b842b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6002074371db6c6a51dbd6a196b842b7">&#9670;&#160;</a></span>ReleaseFixedConnector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trpc::ServiceProxy::ReleaseFixedConnector </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>connector_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a fixed connection (not thread-safe). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connector_id</td><td>connection identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success，false on failed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When releasing, it is necessary to ensure that there is no data interaction on the current fixed connection. The same connection can only be released once. If the release fails, it can be retried. </dd></dl>

</div>
</div>
<a id="a6fbcdb6734b1a986c9488cefecf3dff3" name="a6fbcdb6734b1a986c9488cefecf3dff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbcdb6734b1a986c9488cefecf3dff3">&#9670;&#160;</a></span>UnaryInvoke()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrpc_1_1_status.html">Status</a> trpc::ServiceProxy::UnaryInvoke </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtrpc_1_1_ref_ptr.html">ClientContextPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProtocolPtr &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProtocolPtr &amp;&#160;</td>
          <td class="paramname"><em>rsp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous call interface oriented to transport (thread-safe). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td><a class="el" href="classtrpc_1_1_protocol.html" title="An interface representing the ability to decode and encode a protocol message.">Protocol</a> object with serialized request body data. </td></tr>
    <tr><td class="paramname">rsp</td><td><a class="el" href="classtrpc_1_1_protocol.html" title="An interface representing the ability to decode and encode a protocol message.">Protocol</a> object with body data not yet serialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK status on success, otherwise on failed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The implementation of this interface is thread-blocking in IO/Handle separation or merging mode, and non-thread-blocking in <a class="el" href="classtrpc_1_1_fiber.html" title="Analogous to std::thread, but it&#39;s for fiber.">Fiber</a> mode. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>trpc/client/<a class="el" href="service__proxy_8h_source.html">service_proxy.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 10 2023 16:03:03 for tRPC-Cpp by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
